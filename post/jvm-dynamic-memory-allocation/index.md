> 这篇是对《深入理解Java虚拟机》的第二章的总结笔记

## 1 运行时数据区 (Runtime Data Areas)
### 1.1 Java堆  (Java Heap)

* 虚拟机启动时创建，**线程独立**：所有线程共享；
* 目的是存放对象实例和数组，几乎所有对象都在堆中分配内存；
* 垃圾收集器的管理的主要区域，又叫GC堆；
* 因为GC大多采用分代收集算法，堆又可以分成**新生代**和**老年代**，新生代又可分为**伊甸园**，**幸存者空间1**，**幸存者空间2**；
* 堆在物理上可以是在不连续的空间，但是逻辑上是连续的；
* 主流虚拟机的堆是可扩展的（JVM标准规定可以实现成固定大小的），通过-Xmx/-Xms决定，如果堆中内存不足以分配实例，且不能扩展，就会抛出OutOfMemoryError异常。

<!--more-->

### 1.2 方法区 (Method Area)

* **线程独立**：所有线程共享；
* 目的是存放类信息，常量，静态变量，二进制字节码的代码，HotSpot虚拟机加载类的时候创建的类对象也存放于此；
* HotSpot用GC管理此区域，也叫做**永久代**，GC主要进行常量池的回收和对类型的卸载；
* 无法满足内存分配需求是抛出OutOfMemoryError异常。
* 其中有**运行时常量池**，Class文件中的常量池（包括字面量和符号引用）将在类被加载后进入运行时常量池；运行时常量池通常还会储存解析后的直接引用；

### 1.3 程序计数器(Program Counter Register)

* 线程隔离：每个线程独立使用；
* 用于指示当前线程所执行字节码的行号；
* 如果当前线程在执行一个Java方法，则它记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，则是未定义的。
* Java多线程由线程切换并分配处理器时间的方式实现，因此为了恢复线程到上次执行的位置，每个线程需要有独立的程序计数器。

### 1.4 Java虚拟机栈（VM Stack）

* 线程隔离：每个线程独立使用；
* 每个方法在执行时都会创建一个栈帧，用于储存局部变量表（编译期间确定大学，运行时不变），操作数栈，动态链接，方法出口灯，一个方法的调用到结束，对应着一个栈帧在虚拟机栈的入栈到出栈的过程；
* 请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常，如果虚拟机允许动态扩展，但是无法申请到足够内存，就会抛出OutOfMemoryError异常。

### 1.5 本地方法栈(Native Stack Method)

* 同Java虚拟机栈，前者为Java方法也就是字节码服务，本地方法栈为Native方法服务；
* 异常同虚拟机栈。

## 2 对象的创建

1. 虚拟机遇到new指令时，先检查这个指令的参数能否在常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有则进行**类加载过程**（见类加载机制）；
2. 分配内存。
  * 划分可用空间问题。指针碰撞(Bump the Point)方法：Java堆中内存是绝对规整的，也就是GC是带有压缩整理功能的，比如Serial, ParNew；空闲列表(Free List)：虚拟机维护一个列表记录哪些内存块是可用的，GC并不压缩整理，比如CMS这种基于mark-sweep的。
  * 内存分配动作的线程安全问题。同步处理：采用CAS加上失败重试来保证原子性；使用本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，线程在各自的TLAB上分配内存，在TLAB用完需进行性的TLAB分配时才需要同步锁定。
3. 将分配的内存空间初始化为零值。
4. 对对象进行设置，比如对象的哈希码，GC分代年龄信息，属于哪个类的实例等，这些都放在对象头(Object Header)中。
5. 执行<init>对象构造器方法。

## 3 对象的内存布：分为对象头，实例数据和对其填充
### 3.1 对象头

* Mark Word：一个32位或者63位的信息，取决于虚拟机是32位还是64位。储存包括哈希码，GC分代年龄，锁状态标志，线程所持有的锁，偏向线程ID，偏向时间戳等。它被设计成一个非固定数据结构，可以根据对象不同状态复用自己的储存空间。
* 类型指针：指向类元数据的指针，用来确定对象是哪个类的实例；
* 如果是数组，则还要记录长度。

### 3.2 实例数据

* 包括从父类继承的和子类中定义的；
* 储存顺序受虚拟机分配策略参数和字段在源代码中定义的顺序影响：
  1. HotSpot为longs/doubles, ints, shorts/chars, bytes/booleans, ordinary object pointers
  2. 在满足上述条件下，父类中定义的变量出现在子类之前；
  3. 如果CompactFields被设置，子类中较窄的变量也可能插入到父类变量的空隙中。

### 3.3 对象填充

* HotSpot要求对象起始地址必须为8字节的整数倍，对象头正好是8字节的倍数（1倍或2倍），如果实例数据没有对齐，则需要填充。

## 4 对象访问

通过栈上的reference数据来操作堆上的具体对象，访问具体对象的方法分为：

### 4.1 句柄

* 堆中划分出一块空间用来作为句柄池。栈中的reference指向句柄地址，两个句柄指针分别指向对象实例地址（在堆中）和对象类型数据地址（在方法区中）。这种定位对象的好处是reference比较稳定，当GC时，对象很可能会被移动，这只要改变句柄中的实例地址指针就可以，reference不需要修改；不好的地方是需要进行两次定位，有额外开销。

### 4.2 直接指针访问

* reference储存的直接就是对象在堆中的地址，对象空间再保存类型数据地址。好处是找到对象只需要进行一次指针定位。

## 5 虚拟机参数

* -Xms 堆最小值，比如-Xms20m表示堆最小值为20MB；
* -Xmx 堆最大值，将-Xms和-Xmx设置成相同可以避免堆自动扩展；
* -Xss栈容量
* -MaxPermSize最大方法区容量
* 操作系统内存限制-Xmx-MaxPermSize剩下的就被分给了栈和本地方法栈，可以通过减少最大堆和减少栈容量来换取更多线程。