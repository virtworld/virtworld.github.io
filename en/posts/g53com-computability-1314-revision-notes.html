<!DOCTYPE html><html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Jiaqi Li">
    <title>G53COM Computability 1314 Revision Notes | Virtual World</title>
    
            <link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
      <link rel="canonical" href="http://www.jiaqili.me/en/posts/g53com-computability-1314-revision-notes.html">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
                <link rel="alternate" type="application/rss+xml" title="RSS (en)" href="../rss.xml">
                <link rel="alternate" type="application/rss+xml" title="RSS (zh_cn)" href="../../rss.xml">

    



                <link rel="alternate" hreflang="zh_cn" href="../../posts/g53com-computability-1314-revision-notes.html">


    
</head>
<body>
<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container-fluid"><!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://www.jiaqili.me/">Virtual World</a>
        </div><!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li><a href="../../archive.html">Archives</a>
                </li><li><a href="../../categories/index.html">Tags</a>
                </li><li><a href="../../rss.xml">RSS</a>
                </li><li><a href="../stories/about.html">About</a>

            </li></ul>

            <ul class="nav navbar-nav navbar-right">
                
                    <li>
            </li><li><a href="../../index.html" rel="alternate" hreflang="zh_cn">简体中文</a></li>

                
                    
    <li>
    <a href="../.././en/posts/g53com-computability-1314-revision-notes.md" id="sourcelink">Source</a>
    </li>

            </ul>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
</nav>

<!-- End of Menubar -->

<div class="container">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
    <article class="postbox post-text">
    <div class="h-entry" itemscope="itemscope" itemtype="http://schema.org/Article">
    
    <h1 class="p-name" itemprop="headline name">G53COM Computability 1314 Revision Notes</h1>

    <hr>
    <small>
        Posted: <time class="published dt-published" datetime="2014-06-01T20:54:42+00:00" itemprop="datePublished">2014-06-01 20:54</time>
        
                  |  
                <a href="../../posts/g53com-computability-1314-revision-notes.html" rel="alternate" hreflang="zh_cn">中文版</a>

        

    </small>
    <hr>
    <div class="e-content" itemprop="articleBody text">
    <div><p><em>Contents based on G53COM lecture slides 1314 by <a href="http://www.cs.nott.ac.uk/~ajp/">Dr Andrew Parkes</a></em><br>
<em>These are <strong>NOT</strong> sample answers. Any definition, explanation or example listed below could be imprecise or incorrect. Please refer to your own notes and lecture slides.</em></p>
<h2>1. Definitions</h2>
<h3>Problem Classes</h3>
<ul>
<li><strong>NC</strong> is a set of problem that can be solved in polylog time using polynomial a number of processors.</li>
<li><strong>DTIME(f(n))</strong> is a set of problem that can be solved using some DTM in time f(n).</li>
<li><strong>P = U<sub>k</sub> DTIME(n<sup>k</sup>)</strong> is a set of problem that can be solved using a DTM in any polynomial time.</li>
<li><strong>P-hard</strong>: if a problem X is said to be P-hard iff all problems within P can be reduced to X using polylog time on a polynomial number of processors.</li>
<li><strong>P-complete</strong>: if a problem X is said to be P-complete iff it is in P and it is P-hard.</li>
<li><strong>NTIME(f(n))</strong> is a set of problem that can be solved using some NDTM in time f(n).</li>
<li><strong>NP = U<sub>k</sub> NTIME(n<sup>k</sup>)</strong> is a set of problem that can be solved using some NDTM in any polynomial time. A language is accepted by a NDTM is a set of strings that there exists one or more than one execution path of NDTM that gives yes.</li>
<li><strong>Reduction from X to Y</strong>: convert any instance of X to some instance of Y.</li>
<li><strong>NP-hard</strong>: if a problem X is said to be NP-hard iff any problem in NP can be reduced to X in polynomial time.</li>
<li><strong>NP-complete</strong>: if a problem X is sad to be NP-complete iff it’s in NP and it’s NP-hard.</li>
<li><strong>DSPACE(f(n))</strong> is a set of problem that can be solved using some DTM with space f(n).</li>
<li><strong>PSPACE = U<sub>k</sub> DSPACE(n<sup>k</sup>)</strong> is a set of problem that can be solved by a DTM using polynomial space.</li>
<li><strong>PSPACE-hard</strong>: if a problem X is said to be PSPACE-hard iff any problem in PSPACE can be reduced to X within polynomial time.</li>
<li><strong>PSPACE-complete</strong>: if a problem is PSPACE-complete if it is in PSPACE and it is PSPACE-hard.</li>
<li><strong>NSPACE(f(n))</strong> is a set of problem that can be solved using some NTDM with space f(n).</li>
<li><strong>NPSPACE = U<sub>k</sub> NSPACE(n<sup>k</sup>)</strong> is a set of problem that can be solved using a NTDM with polynomial space.</li>
</ul>
<h3>Relationship</h3>
<p><strong>NC ⊆ P ⊆ NP ⊆ PSPACE = NPSPACE</strong></p>
<ul>
<li><strong>P ⊆ PSPACE</strong>, because a poly time TM cannot use more than polyspace (space can be reuse, but time cannot). </li>
<li><strong>NP ⊆ PSPACE</strong>, a NDTM can be seen as an execution tree with polynomial height, any one execution path has a length of at most polynomial time. We can solve NP problem in PSAPCE by using DFS to explore the tree of possible executions due to non-determinism. Hence NP in PSPACE. </li>
<li><strong>Savitch’s theorem</strong>: NSPACE(f(n)) ⊆ DSPACE(f(n)<sup>2</sup>)  </li>
<li><strong>Prove PSPACE = NPSPACE</strong><br>
      NSPACE(f(n)) ⊆ DSPACE(f(n)<sup>2</sup>) by Savitch<br>
      NPSPACE = U<sub>k</sub> NSPACE(n<sup>k</sup>) by def.<br>
      =&gt; NPSPACE ⊆ U<sub>k</sub>DSPACE(n<sup>k</sup>)<br>
      =&gt; NPSPACE ⊆ PSPACE<br>
      It is trivial that PSPACE ⊆ NPSPACE.<br>
      Hence, NPSPACE = PSPACE  </li>
</ul>
<h2>2. Turning Machine, Enumeration and Solvability</h2>
<h3>Deterministic Turing Machine.</h3>
<p>Turing machine is a model of computation that consists of a 7-tuples<br>
</p><table>
    <tr><td>Q</td><td>A finite set of states</td></tr>
    <tr><td>Γ</td><td>A finite set of tape alphabet</td></tr>
    <tr><td>q0 ∈ Q</td><td>An initial state</td></tr>
    <tr><td>F ⊆ Q</td><td>A set if final states</td></tr>
    <tr><td>b ∈ Q</td><td>A blank symbol</td></tr>
    <tr><td>Σ ⊆ Γ \ b</td><td>A set of input symbols</td></tr>
    <tr><td>δ: Q \ F x Γ -&gt; Q x Γ  x {L, R, N}</td><td>A Transition function that takes a state (not final one) and a tape symbol, returns a new state, a new tape symbol and movement which is left, right or stay.</td></tr>
</table>
A TM is deterministic if and only if the action for any current state q and any symbol that can occur when the machine is in state q is unique. An action is 5-tuples: (current state, current tape symbol, new state, new state and direction of move)  
<h3>Universal Tuning Machine</h3>
<p><strong>Motivation and concept</strong> For every new problem, we need a TM to solve, but general purpose computer can execute any program that stored on hard disk. A Universal Turning Machine acts as an interpreter that takes e(M) and executes it on input s.<br>
<strong>Construct and work.</strong> UTM uses fixed states, alphabet and transitions. The program M encodes the set of tuples of an arbitrary TM with arbitrary states and program. The input of the target TM is also stored on tape as s. UTM runs on e(M)&amp;s, keeps track of simulated head of M and its real head, keeps track of current state of target TM.</p>
<h3>Non-Deterministic Turing Machine.</h3>
<p>Non-deterministic Turing Machine is a Turning Machine that has more than one possible transition for a given state and a tape symbol. This means for more than one execution path. An NDTM M is said to accept a string s if and only if there is some execution path that leads to halting with yes. Usage: It is the vital concept to the NP definition.<br>
Simulate NDTM with DTM: Breadth First Search or iterative deepening on NDTM</p>
<h3>REC and RE</h3>
<p>A language L is decided by a Turing Machine M if and only if:  </p>
<ul>
<li>s in L implies M is guaranteed to halt with yes.  </li>
<li>s not in L implies M is guaranteed to halt with no.</li>
</ul>
<p>If a Turning Machine is existed with such property, then L is <strong>Recursive Language (REC)</strong>.<br>
A Language L is accepted by a Turing Machine M if and only if:  </p>
<ul>
<li>s in L implies M is guaranteed to halt with yes.  </li>
<li>s not in L implies M either halt with no or it never halt.  </li>
</ul>
<p>If a Turning Machine is existed with such property, then L is <strong>Recursive Enumerable (RE).</strong>  </p>
<h3>Enumerate strings of a language</h3>
<p>Enumerating strings of language L means explicitly produce the elements of L and put it into a list (print it). This requires only the strings that belongs to L are printed, and all strings in L are eventually printed.</p>
<h3>Give and explain a method to enumerate the strings of a REC</h3>
<p>The method is generate and test. Generate all string s in the REC, test each s by a TM and print out those given a ‘yes’.</p>
<div class="code"><pre><span class="n">Repeat</span>
    <span class="n">Generate</span> <span class="n">a</span> <span class="n">string</span> <span class="n">w</span>
    <span class="n">Check</span> <span class="k">if</span> <span class="n">w</span> <span class="n">belongs</span> <span class="n">to</span> <span class="n">L</span> <span class="n">by</span> <span class="n">a</span> <span class="n">TM</span><span class="p">.</span> <span class="n">If</span> <span class="n">yes</span><span class="p">,</span> <span class="n">print</span> <span class="n">w</span><span class="p">;</span> <span class="k">if</span> <span class="n">no</span><span class="p">,</span> <span class="n">ignore</span> <span class="n">w</span><span class="p">.</span>
</pre></div>


<h3>Give and explain a method to enumerate the strings of a RE</h3>
<p>The idea is still generate and test but run each test on a separate thread. The number of thread is unbounded but always finite, any element of L will be printed out in finite time, because the ‘yes’ is guaranteed to halt.  </p>
<div class="code"><pre><span class="n">Assume</span> <span class="n">TM1</span> <span class="n">accepts</span> <span class="n">language</span> <span class="n">L</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">TM2</span> <span class="n">generate</span> <span class="n">new</span> <span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">and</span> <span class="n">start</span> <span class="n">a</span> <span class="n">new</span> <span class="kr">thread</span> <span class="k">for</span> <span class="n">each</span> <span class="n">one</span> <span class="n">that</span> <span class="n">runs</span> <span class="n">TM1</span> <span class="n">on</span> <span class="n">string1</span><span class="p">;</span>
    <span class="n">Run</span> <span class="n">each</span> <span class="kr">thread</span> <span class="k">for</span> <span class="n">some</span> <span class="n">number</span> <span class="n">of</span> <span class="n">steps</span><span class="p">.</span> 
        <span class="n">If</span> <span class="n">one</span> <span class="kr">thread</span> <span class="n">halt</span><span class="p">,</span> <span class="n">print</span> <span class="n">yes</span><span class="p">;</span> <span class="n">If</span> <span class="n">not</span> <span class="n">halt</span><span class="p">,</span> <span class="n">just</span> <span class="n">carry</span> <span class="n">on</span><span class="p">.</span>
</pre></div>


<h3>Halting problem and its importance</h3>
<p>Given a TM M and an input string x, let e(M) be the encoding of M. Does there exist an effective procedure (computable function) for deciding, for every pair (e(M), x) that does M halt for x?</p>
<p>It is equivalent to ask whether the language L = {e(M)&amp;s | M halts for s} is recursive (it is RE)?</p>
<p>The proof of the unsolvability of many problems relies on the unsolvability of Halting problem.</p>
<h3>Halting theorem: The Halting problem for Turing machine is unsolvable.</h3>
<p>Assume the Halting problem is solvable, then there exists a Turing machine H that decides the Halting problem. If H can solve the Halting problem for input e(M)&amp;x, H should be able to solve the Halting problem for input e(M)&amp;e(M).</p>
<p>Let H’ be a Turing machine that takes e(M) and makes a copies to obtain e(M)&amp;e(M). Then the H’ execute H with the input e(M)&amp;e(M), but in the case that M halts (that is H halts with yes), H’ loops forever.</p>
<p>If the input of H’ is e(H’), then </p>
<ul>
<li>If H’ halts for e(H’), then H answers yes and H’ loops for ever.</li>
<li>If H’ does not halts for e(H’), then H answers no and H’ halts.</li>
</ul>
<p>Both give a contradiction. Neither H nor H’ exists, hence Halting problem is unsolvable.</p>
<p>Note1: Halting theorem says for any fixed reasoning system, there are instances on which it fails. But NOT says, there are instances for which all reasoning systems fail.</p>
<p>Note2: [WRONG] For any TM M and input, there does not exist a TM H decides whether M halts.
For a single pair of TM and input, there are always a TM that gives either yes or no, but we don’t know which one.</p>
<h3>The general structure/technique of the prove: Self-reference with a twist.</h3>
<p>In the uncountability of real number, we take the entries of diagonal and twist it by adding one to each entries. </p>
<p>In the barber paradox, the problem is the self-reference with negation in defining the set of people shaved by the barber.</p>
<h3>Decision Problems and Reduction</h3>
<p>Decision problem can be states as a question of some formal system with yes/no answer.</p>
<p>If the decision problem is solvable, then there exist a TM that for every instance of the problem, it halts with output yes or no.</p>
<p>pi reduced to pi’ = An algorithm to solve pi’ can be directly used to solve pi. </p>
<ul>
<li>If pi reduced to pi’ and pi’ is solvable then pi is solvable.</li>
<li>If pi reduced to pi’ and pi is unsolvable then pi’ is unsolvable.</li>
</ul>
<h3>Empty word halting problem</h3>
<p>Give a TM M. Does M halt on epsilon? </p>
<p>Proof: (1) show eHP reduced to HP. (2) Assume eHP is solvable. (3) HP is solvable -&gt; contradiction.</p>
<p>Assume an instance of HP, M and x; an instance of eHP, M’ and empty string e. M’ first write x onto its tape to simulate M. (eHP reduce to HP). If we can show M’ halts on e, then M halts. This is a contradiction to Halting theorem. Therefore, eHP is unsolvable.</p>
<h2>3. NP-hardness and Reductions</h2>
<h3>Polynomial time reduction and how reduction are used to show problems are in NP-complete</h3>
<p>Given any instance of a problem class X.</p>
<p>Computer an instance f(x) in problem class Y with the conversion done in polynomial time and the answer preserved, i.e., ans(x) = yes if fans(f(x)) = yes.</p>
<p>To show NP-complete, we need to show NP-hard. If a problem is said to be NP-hard iff all problems in NP can be reduced to it in polytime.</p>
<h3>Decision Problems</h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a></li>
<li><a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability">k-SAT</a></li>
<li>[MONOTONE-k-SAT]</li>
<li>[KNAPSACK]</li>
<li>[BIN PACKING]</li>
<li>[HAMILTONIAN CYCLE]</li>
<li>[TSP(D)]</li>
<li>[CIRCUIT SAT]</li>
<li><a href="http://en.wikipedia.org/wiki/Subset_sum_problem">SUBSET SUM</a></li>
<li>[NUMBER PARTITION]</li>
<li>[GRAPH COLOURING]</li>
<li>[INDEPENDENT SET]</li>
<li>[CLIQUE]</li>
<li>[VERTEX COVER]</li>
</ul>
<h3>Prove SAT is HP-hard(informal, read more on <a href="http://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem">Cook-Levin Theorem</a>)</h3>
<p>If SAT is NP-hard, then every problem in NP can be reduced to SAT in polynomial time. </p>
<p>According to the definition of NP problem, this means:<br>
Given an input s of size n, an arbitrary NDTM M that run in polynomial time p(n).</p>
<p>We need to convert the NDTM and input into a SAT formula in polynomial time, such that the NDTM has an accepting computation if and only if the SAT formula has a satisfying assignment.</p>
<ol>
<li>
<p>Using variables in the form of function of time t to describe states</p>
<ul>
<li>x(i, t) = 1 iff the machine in state i at time t  </li>
<li>y(i, k, t) = 1 iff the tape element i has value k at time t  </li>
<li>z(i, t) = 1 iff the head is at position i at time t  </li>
</ul>
<p>If all values of these variables are given, then the execution sequence of NDTM is given.</p>
</li>
<li>
<p>The transition to reach state at time t + 1 only depends on state at time t and a non-determinism choice w(c, t) meaning choice c at time t.
These could be expressed using polynomial size clauses. </p>
</li>
</ol>
<p>The NDTM is converted into a polysize SAT formula containing variables describing the states as a function of time and allowing the need of non-determinism. The SAT formula has a satisfying formula iff there is some sequence of states of the NDTM that lead to acceptance.</p>
<p><em>(To be finished...)</em></p></div>
    </div>
    </div>
    

        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="nikolademo",
            disqus_url="http://www.jiaqili.me/en/posts/g53com-computability-1314-revision-notes.html",
        disqus_title="G53COM Computability 1314 Revision Notes",
        disqus_identifier="cache/posts/g53com-computability-1314-revision-notes.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


    

    </article>

        </div>
        <!--End of body content-->

        <footer>
            Contents © 2014         <a href="mailto:alex.jiaqi.li#gmail.com">Jiaqi Li</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">
 <img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="http://i.creativecommons.org/l/by-nc-sa/2.5/ar/88x31.png"></a>
        </footer>
    </div>
</div>


            <script src="../../assets/js/all-nocdn.js" type="text/javascript"></script>


    

    <script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    

</body>
</html>