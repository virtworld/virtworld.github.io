<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Virtual World</title><link>http://www.jiaqili.me/</link><description>Jiaqi Li's personal blog</description><atom:link href="http://www.jiaqili.me/en/rss.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Wed, 23 Jul 2014 21:25:21 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>英国计算机研究生申请</title><link>http://www.jiaqili.me/en/posts/taught-master-in-computer-science-application.html</link><description>&lt;div&gt;&lt;p&gt;作者：&lt;a href="http://www.jiaqili.me/"&gt;Jiaqi Li&lt;/a&gt;  |  授权方式：&lt;a href="http://creativecommons.org/licenses/by-nc-nd/4.0/"&gt;CC BY-NC-ND 4.0&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;0. 背景&lt;/h2&gt;
&lt;p&gt;这篇文章主要针对宁诺学生，介绍的是英国计算机授课型研究生的申请，特别是牛津和帝国理工，部分内容也可能适用于其他地区、学校和专业。申请时间是1314学年，请注意时效性，一切以官网为准。&lt;/p&gt;
&lt;h2&gt;1. 从大一到大三&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;大三结束的同学可以跳过&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1.1 选课&lt;/h3&gt;
&lt;p&gt;选课的时候可以考虑主修方向，个人兴趣和难易程度。 &lt;/p&gt;
&lt;p&gt;首先，如果明确自己以后要学什么，可以将选修课程的大部分集中在那个区域里，你的PS和成绩单会非常有说服力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;比如计算机图形，可以学一下Computer Graphics, Introduction to Image Processing, Computer Vision等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比如机器学习，可以学一下Introduction to Modelling and Optimisation, Machine Learning, Data Mining Techniques and Applications等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再比如系统网络方向，Computer Communications and Networks, Advanced Computer Communications, Parallel and Distributed Computing, Computer Security, Operating Systems, Concurrency, Connected Computing at Scale等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AI方向有Knowledge Representation and Reasoning, Autonomous Robotic Systems, Designing Intelligent Agents, AI Programming Techniques；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有HCI方向的Graphical User Interfaces, Human Computer Interaction, Collaboration and Communication Technologies 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这只是一个建议，并不是严格的分类，课程本身都有交叉。另外，如果涉及到数学基础很强的方向，比如机器学习，建议选一些数学学院或者工程学院下面的数学课，宁诺计算机教的数学真是完全不行（真的有教过？）。如果没有明确方向的话，其实也没关系。本科阶段最好多涉猎一点各方面的内容，特别在前两三年，知识的广度比深度更重要。&lt;/p&gt;
&lt;p&gt;除了主修方向以外，其他的课程可以按照自己的兴趣来选。第一，感兴趣的课程一般容易学，容易拿分；第二，如果一学期这么多课里一门都不喜欢，读书一定很痛苦。&lt;/p&gt;
&lt;p&gt;最后的难易程度直接涉及到分数问题。每年因为课程大纲的变化，任课老师的变动，都有一些课容易拿分，有些则很难。除了问学长学姐以外，每学期开始一两周都是可以试听的，所以每门课都去听一下，感受一下，也可以直接问老师关于分数的问题，他们也是过来人，一般愿意回答。&lt;/p&gt;
&lt;h3&gt;1.2 成绩&lt;/h3&gt;
&lt;p&gt;虽然只有大三大四的成绩会决定你的学位等级，并且申研时最重要的是大三成绩，但是剑桥要求提供所有成绩，牛津，帝国也可能被要求大一和大二的成绩。其中和所申请专业有关系的科目的成绩比较重要，但也会看你大一的英语成绩。&lt;/p&gt;
&lt;p&gt;英国授课型研究生的申请最简单的玩法是看成绩，复杂玩法包括很牛的推荐人，发表过论文，参加国际比赛比如ACM-ICPC并且拿奖，在比如微软亚洲研究院实习等等。如果复杂的玩不好，请努力提高成绩。开始申请前，大三的成绩基本上决定了你能申请到什么样的学校。&lt;/p&gt;
&lt;p&gt;对于申请牛剑帝，如果没有到70，录取机会比较小，但也有成功的例子。分数在75分以上，其他部分（比如面试，PS，推荐信等后文会介绍）不出问题，基本上可以进至少一所。分数更高一点，可以弥补个别材料的瑕疵，比如PS，CV，面试等。&lt;/p&gt;
&lt;p&gt;对于UCL，要求60以上。有50+录取的例子，也有70被拒的。取决于具体专业，有些比较热门；也取决于你的专业是否和你所学知识对口。&lt;/p&gt;
&lt;h2&gt;2. 大三暑假&lt;/h2&gt;
&lt;p&gt;如果你想去美国，暑假里或更早的时候，应该把GRE考掉（MIT不需要，有志于MIT的同学可以试一下）。&lt;/p&gt;
&lt;p&gt;这篇文章假设你的申请目标是英国，没有GRE，但是根据你的情况可能需要雅思。如果你是2+2项目，基本上没有学校会问你要语言成绩，至少牛剑帝不需要，不排除个别学校比如据说爱丁堡还是要雅思，也不排除因为自身原因被con雅思。但你可以去试一下自己的英语水平，一个不错的成绩（雅思各项7+）对申请会有加分。如果你是4+0，牛剑基本上各项都要7+，帝国可以低一点，请参考官网。建议大三暑假前考出，大四会比较忙，或者到拿到offer后再考，压力会大一点。&lt;/p&gt;
&lt;p&gt;暑假里成绩出来以后，给自己定位一下，选5所理想的学校，每个学校选好专业。如果你不打算美国这条路，剩下的就是英国，香港，加拿大，新加坡，澳洲这些地方的学校都可以进入你的考虑范围，但是整体数量也不多。牛剑9月份开放申请，帝国11月份开放申请，截止日期一般到3月份，之后名额就很少或者没有了。英国的其他学校申请时间都很长，有些甚至7月份还有名额。但是香港，加拿大等其他国家很多高校截止较早，如果有兴趣，请关注他们的官网。
假设你的大三成绩在75+，一般首选英国排名前三的学校，再加一两所保底，如果因为其他原因，比如就业、移民等特别想去某个地方的，也可以考虑新加坡、澳洲等高校。70-75一般冲一下前三，但很可能进UCL，这个分数申请香港各高校均没问题。60-70基本上把精力放在UCL这个档次上，同时也可以考虑布里斯托，爱丁堡，南安普顿等英国计算机比较好的学校。50-60可以考虑本校。&lt;/p&gt;
&lt;p&gt;有了定位以后，可以准备一下自己的申请材料——PS和CV（下文具体讲）。我自己假期里考了个雅思，看了些学校的信息，其他的东西，比如材料准备，都是到10月份之后才开始的。所以，所以实践证明，大四开学后（来英国以后）再开始准备是可行的。甚至某同学圣诞节才开始写PS。&lt;/p&gt;
&lt;p&gt;加一段比较主观的内容。不要找中介。中介唯一能做的事情就是写PS，接下来会介绍如何写。中介还能做什么，填申请表？没任何难度，都是个人信息。找老师写推荐信？自己一封邮件可以搞定。面试？学校Career的外教给你提供模拟面试训练（虽然我没有试过）。签证？2+2同学都签过，4+0同学请咨询你们的校友。总之，我觉得中介是挺浪费钱的，除了可能会给你省时间。&lt;/p&gt;
&lt;h2&gt;3. PS&lt;/h2&gt;
&lt;p&gt;PS是可能是所有材料里最开放的，准备时间最长的东西。最重要的是内容，其次是结构，这些做的好能给你加分，不好会减分；文采，语法，拼写，标点，排版等等都是相对次要的。一个合格的PS应该是：当老师读完以后，即便没有见过你，但是他的脑子里已经得有你这个人的生动的形象了，并且这个形象符合他们录取标准。所以PS要真实，具体，突出自己的特点。一般不会写自己的缺点，或做的不好的地方，除非你是用它来反衬出自己某些品质，比如因为勤工俭学，导致影响了成绩，但是最后还是如何如何。&lt;/p&gt;
&lt;h3&gt;3.1 PS的内容&lt;/h3&gt;
&lt;p&gt;有些学校对PS内容有要求，比如牛津和UCL，那就一定按照要求来。他们要你写的地方你都要照顾到，但不是列举，而是渗透到文章中，并从文章中体现出来。比如你想要表达自己善于快速思维，解决问题。就可以用具体的例子，比如参加学校某个活动，做了哪些事情。如果没有要求，一般可以cover到这些点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你为什么选择这个学校？这个专业？你的未来规划是什么？&lt;/li&gt;
&lt;li&gt;你的motivation是什么？为什么你觉得你能胜任这个课程？&lt;/li&gt;
&lt;li&gt;你是否有commitment来完成这个课程？&lt;/li&gt;
&lt;li&gt;你的特点，个性是否符合我们的期望？&lt;/li&gt;
&lt;li&gt;你希望从这个课程中得到什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请用具体的经历来反应出上面的很多问题，不要枚举，也不要写成散文。别忘了PS是体现你这个“人”的，如果你的PS读完以后，感觉和CV一样的话，那基本就废了。另一点就是，凡是CV和Transcript上提到的东西，PS没有展开来写的就不要点到了。&lt;/p&gt;
&lt;p&gt;不要讲故事，的确有很多模板是以故事开头的，而且的确写的很好，但是：“我从就喜欢计算机……”，然后扯上一段。除非你的英语能力达到了能够使人听了以后非常信服的程度，不然听上去真的像故事。&lt;/p&gt;
&lt;p&gt;有些学校对PS长度有要求。要求多长就不要超过。没有要求的一般写两页以内。&lt;/p&gt;
&lt;p&gt;对于有面试的申请，不要把自己吹的很高，你的PS将成为你的面试题！对于没有面试的申请，也要真实，没有Evidence的东西尽量少讲，撒谎更是可耻的，材料是记录在案的，就算毕业了，后来被发现申请材料有假，可能也会被取消学位。&lt;/p&gt;
&lt;p&gt;所以写PS可能就一两天，但是准备得一两周。你一定要把自己的经历，能力，特色好好的梳理一下（大学以前的事情就不必提了）&lt;/p&gt;
&lt;h3&gt;3.2 PS的结构&lt;/h3&gt;
&lt;p&gt;PS一般没有固定结构，仅供参考。&lt;/p&gt;
&lt;p&gt;第一段可以写为什么申请这个学校，为什么申请这个专业，我的motivation和我的职业规划。注意衔接，比如说要让人感觉你有明确的motivation，所以你有清晰的目标，为了这个目标，你们学校这个专业是我的最佳选择。&lt;/p&gt;
&lt;p&gt;第二-三段可以写你本科阶段所学的知识。可以把理论和实践分开来讲，也可以按想关科目讲。但是千万别写成CV了，“我学过这个，我知道那个…”。实际上你要回答一个问题“为什么我能胜任这个课程？”答案是“你看，我有这些这些背景”，而你的表述得生动一点，比如你可以通过自己的motivation把这些串起来，或者其他什么方式。你甚至不必提你具体的课，只是让老师知道你学过这些想关知识就可以了。这里内容不在多，而在精，只讲有帮助的。&lt;/p&gt;
&lt;p&gt;第三部分你可以讲自己做过的项目（如果和所申请专业相关），每个人至少做过一个项目，比如你大三你在项目组里担任什么角色，用了什么技术，遇到什么问题，你是如何解决，怎么体现了自己的能力，特点。&lt;/p&gt;
&lt;p&gt;第四部分可以讲课堂外的经历（如果和所申请专业相关），实习，参加竞赛，发表论文，做项目等等只要能体现出对方想要的东西，你就可以加进来。还是不在多而在精&lt;/p&gt;
&lt;p&gt;第五部分可以讲希望从课程中得到什么（表示自己的期望和你们的课程是相符合的），体现下自己的commitment，做个收尾。&lt;/p&gt;
&lt;p&gt;你完全没必要按照我的建议写，甚至我希望你不要因为这个样板而受到拘束。PS是灵活的东西，几乎没有一篇PS是一样的。还是那个词要体现出你的特点（这个模板用的人多了，肯定会成为一个糟糕的模板）。
但是要注意，有些东西你的内容中表现不出来，需要从你的行文中表现。比如你的逻辑思维能力。这考验你CELE的课有没有学好。比如说一段话第一句总起，第二句解释，第三句举例等等。用好连接词，把文章条理弄清楚。总体上来说，很多一部分会是你的个人经历。所以之前的准备工作很重要，之后就是把你搜集出来的各种“相关”经历组织成文，然后加工使她变的符合要求，继而读起来流畅，最后变的生动。&lt;/p&gt;
&lt;h3&gt;3.3 PS的其他&lt;/h3&gt;
&lt;p&gt;虽然排版，语法等等不重要，不用强求，但也请把他们做到你能力范围内的最好。&lt;/p&gt;
&lt;p&gt;排版用LaTex，谷歌之（或者至少要达到CELE交作业的要求）。&lt;/p&gt;
&lt;p&gt;文采靠英语水平，不是一时半会儿能提高的，但是找几篇样本（外国人写的，被Oxbridge录取的）来参考会有很大帮助。&lt;/p&gt;
&lt;p&gt;语法，拼写，标点。请自己和朋友帮忙多读几遍（下面会讲怎么校对）。&lt;/p&gt;
&lt;h3&gt;3.4 PS的修改校对&lt;/h3&gt;
&lt;p&gt;慢慢改，你的第一篇PS需要花最多的时间。从第一稿到完稿中间可能有十几搞，也可能只是读了一遍。但是一般你的第二篇、第三篇PS会很快。&lt;/p&gt;
&lt;p&gt;学校的Career Service或者Academic Clinic Service能看内容结构语法，但是不会给你看的很仔细。他们对于语言问题上的建议，可以重视；内容和结构要自己拿主意。&lt;/p&gt;
&lt;p&gt;自己的Supervisor/Tutor。他们一般都是这个领域的专家，你的PS中涉及的技术问题，有没有不当的地方他们都知道。而且作为过来人，他们也有写这个的经验。找他们改PS是首选，他们的建议不管是内容，结构还是语法（如果是Native Speaker）上都有很大参考作用。但是注意，他们没有义务给你改，请你好好和他们说。&lt;/p&gt;
&lt;p&gt;最后找翻译公司。打印成双面A4一张，翻译公司会给你很仔细的看有没有语法，拼写，标点错误。他们完全不会给你内容上的建议，但是毕竟也是专业人士，语言上的建议可以参考。每次收费就50左右，相比中介几千块上万块就很便宜了。&lt;/p&gt;
&lt;h2&gt;4. CV&lt;/h2&gt;
&lt;p&gt;CV算是最简单的东西，暑假里也可以把CV写好。模板网上有很多，这个相对排版比较重要。可以参加宁波Academic Clinic Service的相关讲座，有帮助。除非你有paper发过，一般不要超过1页。一般可以包括以下内容，按是时间顺序从后到前。
1. 大学及之后的教育经历， 如果有相关课程，也加上。
2. 获得的荣誉
3. 做过的项目，发过的paper
4. 学术上的经历
5. 工作经历
6. 课外活动
7. 技能&lt;/p&gt;
&lt;h2&gt;5. 推荐信&lt;/h2&gt;
&lt;p&gt;找老师写推荐信的原则是，他越熟悉你越好，而不是他职位越高越好。有一个特例是，那个老师在你申请的学校有一定的威望，会有帮助。哪个老师对你了解，完全取决于你。但是一般都会要你最后一年的Supervisor写其中一封。除了Supervisor以外，你还可以找Personal Tutor。他是有义务给你写的，不会拒绝你。其他带过你的老师，比如大三小组项目的老师，也可以找。其他给你上过课的老师，你成绩不错，或者你提问题很多，他记得你的等等也可以找。&lt;/p&gt;
&lt;p&gt;有些老师推荐信写的很快，等你注册他名字后，两个小时就交掉了。有些老师写的比较慢，可能要一个多月。建议留足足够的时间，4-5个礼拜如果不是很急。我觉得这是对老师的尊重吧。就算很急也要说明原因，给几个礼拜的时间写。没有一个礼拜内就要的。&lt;/p&gt;
&lt;p&gt;如何问老师推荐信，参考这篇文章：&lt;a href="http://www.wikihow.com/Ask-Your-Professor-for-a-Letter-of-Recommendation-Via-Email"&gt;How to Ask Your Professor for a Letter of Recommendation Via Email&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6. 申请&lt;/h2&gt;
&lt;p&gt;有些学校九月份开放申请，有些则要等到十一月，请保持关注。申请的原则都是越早越好。&lt;/p&gt;
&lt;p&gt;开放申请以后可以先开始填申请表，不管你有没有PS或者CV。只有剑桥那个系统是要在大概一个月里面都填好的，其他其他学校应该没有时间限制。你可以慢慢写PS，等推荐信。&lt;/p&gt;
&lt;p&gt;如果开学后还没有PS（Research Proposal）和CV，不用急，慢慢开始写吧。等你有了这些文书以后，就开始准备推荐信吧。&lt;/p&gt;
&lt;p&gt;有了PS或者RP，CV，推荐信，填好申请表格就可以提交了。有些学校要提交以后才能给老师提交推荐信的链接，比如UCL。有些学校允许你先提交，然后再等老师推荐信，比如OX和IC。申请表填仔细不要出错。等你按下提交以后，就Out of your hand了。可以休息一下了。&lt;/p&gt;
&lt;h2&gt;7. 面试&lt;/h2&gt;
&lt;p&gt;只有牛津、剑桥、帝国有面试。帝国是连续的审核，如果你提交的早，比如一开放申请没多久就交掉了，那么人少，审核的快，可能一个多礼拜就能有面试通知。牛津是等一批结束以后一起审核，它给出了明确的面试时间（即你知道申请结果的时间前一两周）。不需要面试的其他院校，等你交了表格以后就没你什么事了。&lt;/p&gt;
&lt;h3&gt;7.1 牛津面试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;电话面试，一般15-30分钟，迟到1-3分钟他打过来；&lt;/li&gt;
&lt;li&gt;一开始会寒暄一下，主要是问你将来打算。&lt;/li&gt;
&lt;li&gt;很快进入正题，所有的问题都是技术性的。&lt;/li&gt;
&lt;li&gt;如前文所说，你的PS是最好的面试题，考官喜欢从里面找东西问你，确保你所写的你都掌握，并且能在几秒钟之内答上来。&lt;/li&gt;
&lt;li&gt;另一个是Transcript里的课也是面试题。凡是涉及理论的课，特别是排序算法，图算法，Machine and Language，AI要准备好。&lt;/li&gt;
&lt;li&gt;每个人问的都不一样，取决于你的申请方向（PS）和你所学（Transcript），看网上的经验没用。&lt;/li&gt;
&lt;li&gt;准备好介绍做过的项目，和你的主要经历。&lt;/li&gt;
&lt;li&gt;有的面试官喜欢问概念，有的则完全不问；有的喜欢让你举例子，比如说举一个图灵机不接受的语言；有的让你比较算法的好坏；&lt;/li&gt;
&lt;li&gt;你要在5秒钟内答出来，至少你要不停的讲你的思路，不然超过5秒的停顿，对方会认为你不懂，继而给你提示。&lt;/li&gt;
&lt;li&gt;很多很快得到Offer的面试都在15分钟左右结束了，超过20分钟的面试，一般是你回答的太慢，或者对方想多测试一下你的能力，再做定夺。&lt;/li&gt;
&lt;li&gt;不会让你做个人介绍，也似乎没有人问到你为什么来牛津？这种常见问题。&lt;/li&gt;
&lt;li&gt;好好复习你学过的所有理论专业知识。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;7.2 帝国面试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当面面试，一对一，时间比较长，40-45分钟。&lt;/li&gt;
&lt;li&gt;不会有技术问题, 但是会问你想学什么方向，最好之前研究下他们的官网。&lt;/li&gt;
&lt;li&gt;会让你选一下你想学的课程，为什么选这些。&lt;/li&gt;
&lt;li&gt;会让你介绍你做过的项目。&lt;/li&gt;
&lt;li&gt;帝国面试，比较随意，不建议穿正装，比较像聊天。&lt;/li&gt;
&lt;li&gt;帝国给面试的基本都录取了，牛津申请的基本都给面试了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;8. 录取率&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;牛津MSc in Computer Science 12-13年申请人数是285人，13-14年录取名额是75。&lt;/li&gt;
&lt;li&gt;帝国MSc计算机方面所有小专业，申请人数过千，录取一百多。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>http://www.jiaqili.me/en/posts/taught-master-in-computer-science-application.html</guid><pubDate>Wed, 23 Jul 2014 20:43:42 GMT</pubDate></item><item><title>G53COM Computability 1314 Revision Notes</title><link>http://www.jiaqili.me/en/posts/g53com-computability-1314-revision-notes.html</link><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;Contents based on G53COM lecture slides 1314 by &lt;a href="http://www.cs.nott.ac.uk/~ajp/"&gt;Dr Andrew Parkes&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;These are &lt;strong&gt;NOT&lt;/strong&gt; sample answers. Any definition, explanation or example listed below could be imprecise or incorrect. Please refer to your own notes and lecture slides.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;1. Definitions&lt;/h2&gt;
&lt;h3&gt;Problem Classes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NC&lt;/strong&gt; is a set of problem that can be solved in polylog time using polynomial a number of processors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DTIME(f(n))&lt;/strong&gt; is a set of problem that can be solved using some DTM in time f(n).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P = U&lt;sub&gt;k&lt;/sub&gt; DTIME(n&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; is a set of problem that can be solved using a DTM in any polynomial time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P-hard&lt;/strong&gt;: if a problem X is said to be P-hard iff all problems within P can be reduced to X using polylog time on a polynomial number of processors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P-complete&lt;/strong&gt;: if a problem X is said to be P-complete iff it is in P and it is P-hard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NTIME(f(n))&lt;/strong&gt; is a set of problem that can be solved using some NDTM in time f(n).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP = U&lt;sub&gt;k&lt;/sub&gt; NTIME(n&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; is a set of problem that can be solved using some NDTM in any polynomial time. A language is accepted by a NDTM is a set of strings that there exists one or more than one execution path of NDTM that gives yes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reduction from X to Y&lt;/strong&gt;: convert any instance of X to some instance of Y.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP-hard&lt;/strong&gt;: if a problem X is said to be NP-hard iff any problem in NP can be reduced to X in polynomial time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP-complete&lt;/strong&gt;: if a problem X is sad to be NP-complete iff it’s in NP and it’s NP-hard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSPACE(f(n))&lt;/strong&gt; is a set of problem that can be solved using some DTM with space f(n).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PSPACE = U&lt;sub&gt;k&lt;/sub&gt; DSPACE(n&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; is a set of problem that can be solved by a DTM using polynomial space.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PSPACE-hard&lt;/strong&gt;: if a problem X is said to be PSPACE-hard iff any problem in PSPACE can be reduced to X within polynomial time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PSPACE-complete&lt;/strong&gt;: if a problem is PSPACE-complete if it is in PSPACE and it is PSPACE-hard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSPACE(f(n))&lt;/strong&gt; is a set of problem that can be solved using some NTDM with space f(n).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NPSPACE = U&lt;sub&gt;k&lt;/sub&gt; NSPACE(n&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; is a set of problem that can be solved using a NTDM with polynomial space.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Relationship&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NC ⊆ P ⊆ NP ⊆ PSPACE = NPSPACE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;P ⊆ PSPACE&lt;/strong&gt;, because a poly time TM cannot use more than polyspace (space can be reuse, but time cannot). &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP ⊆ PSPACE&lt;/strong&gt;, a NDTM can be seen as an execution tree with polynomial height, any one execution path has a length of at most polynomial time. We can solve NP problem in PSAPCE by using DFS to explore the tree of possible executions due to non-determinism. Hence NP in PSPACE. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Savitch’s theorem&lt;/strong&gt;: NSPACE(f(n)) ⊆ DSPACE(f(n)&lt;sup&gt;2&lt;/sup&gt;)  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prove PSPACE = NPSPACE&lt;/strong&gt;&lt;br&gt;
      NSPACE(f(n)) ⊆ DSPACE(f(n)&lt;sup&gt;2&lt;/sup&gt;) by Savitch&lt;br&gt;
      NPSPACE = U&lt;sub&gt;k&lt;/sub&gt; NSPACE(n&lt;sup&gt;k&lt;/sup&gt;) by def.&lt;br&gt;
      =&amp;gt; NPSPACE ⊆ U&lt;sub&gt;k&lt;/sub&gt;DSPACE(n&lt;sup&gt;k&lt;/sup&gt;)&lt;br&gt;
      =&amp;gt; NPSPACE ⊆ PSPACE&lt;br&gt;
      It is trivial that PSPACE ⊆ NPSPACE.&lt;br&gt;
      Hence, NPSPACE = PSPACE  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. Turning Machine, Enumeration and Solvability&lt;/h2&gt;
&lt;h3&gt;Deterministic Turing Machine.&lt;/h3&gt;
&lt;p&gt;Turing machine is a model of computation that consists of a 7-tuples&lt;br&gt;
&lt;/p&gt;&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;Q&lt;/td&gt;&lt;td&gt;A finite set of states&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Γ&lt;/td&gt;&lt;td&gt;A finite set of tape alphabet&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;q0 ∈ Q&lt;/td&gt;&lt;td&gt;An initial state&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;F ⊆ Q&lt;/td&gt;&lt;td&gt;A set if final states&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;b ∈ Q&lt;/td&gt;&lt;td&gt;A blank symbol&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Σ ⊆ Γ \ b&lt;/td&gt;&lt;td&gt;A set of input symbols&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;δ: Q \ F x Γ -&amp;gt; Q x Γ  x {L, R, N}&lt;/td&gt;&lt;td&gt;A Transition function that takes a state (not final one) and a tape symbol, returns a new state, a new tape symbol and movement which is left, right or stay.&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
A TM is deterministic if and only if the action for any current state q and any symbol that can occur when the machine is in state q is unique. An action is 5-tuples: (current state, current tape symbol, new state, new state and direction of move)  
&lt;h3&gt;Universal Tuning Machine&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Motivation and concept&lt;/strong&gt; For every new problem, we need a TM to solve, but general purpose computer can execute any program that stored on hard disk. A Universal Turning Machine acts as an interpreter that takes e(M) and executes it on input s.&lt;br&gt;
&lt;strong&gt;Construct and work.&lt;/strong&gt; UTM uses fixed states, alphabet and transitions. The program M encodes the set of tuples of an arbitrary TM with arbitrary states and program. The input of the target TM is also stored on tape as s. UTM runs on e(M)&amp;amp;s, keeps track of simulated head of M and its real head, keeps track of current state of target TM.&lt;/p&gt;
&lt;h3&gt;Non-Deterministic Turing Machine.&lt;/h3&gt;
&lt;p&gt;Non-deterministic Turing Machine is a Turning Machine that has more than one possible transition for a given state and a tape symbol. This means for more than one execution path. An NDTM M is said to accept a string s if and only if there is some execution path that leads to halting with yes. Usage: It is the vital concept to the NP definition.&lt;br&gt;
Simulate NDTM with DTM: Breadth First Search or iterative deepening on NDTM&lt;/p&gt;
&lt;h3&gt;REC and RE&lt;/h3&gt;
&lt;p&gt;A language L is decided by a Turing Machine M if and only if:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s in L implies M is guaranteed to halt with yes.  &lt;/li&gt;
&lt;li&gt;s not in L implies M is guaranteed to halt with no.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If a Turning Machine is existed with such property, then L is &lt;strong&gt;Recursive Language (REC)&lt;/strong&gt;.&lt;br&gt;
A Language L is accepted by a Turing Machine M if and only if:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s in L implies M is guaranteed to halt with yes.  &lt;/li&gt;
&lt;li&gt;s not in L implies M either halt with no or it never halt.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If a Turning Machine is existed with such property, then L is &lt;strong&gt;Recursive Enumerable (RE).&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;Enumerate strings of a language&lt;/h3&gt;
&lt;p&gt;Enumerating strings of language L means explicitly produce the elements of L and put it into a list (print it). This requires only the strings that belongs to L are printed, and all strings in L are eventually printed.&lt;/p&gt;
&lt;h3&gt;Give and explain a method to enumerate the strings of a REC&lt;/h3&gt;
&lt;p&gt;The method is generate and test. Generate all string s in the REC, test each s by a TM and print out those given a ‘yes’.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;Repeat&lt;/span&gt;
    &lt;span class="n"&gt;Generate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;
    &lt;span class="n"&gt;Check&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;belongs&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;TM&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;yes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ignore&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Give and explain a method to enumerate the strings of a RE&lt;/h3&gt;
&lt;p&gt;The idea is still generate and test but run each test on a separate thread. The number of thread is unbounded but always finite, any element of L will be printed out in finite time, because the ‘yes’ is guaranteed to halt.  &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;Assume&lt;/span&gt; &lt;span class="n"&gt;TM1&lt;/span&gt; &lt;span class="n"&gt;accepts&lt;/span&gt; &lt;span class="n"&gt;language&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;TM2&lt;/span&gt; &lt;span class="n"&gt;generate&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;runs&lt;/span&gt; &lt;span class="n"&gt;TM1&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;string1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Run&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;steps&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 
        &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;halt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;yes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;halt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;just&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Halting problem and its importance&lt;/h3&gt;
&lt;p&gt;Given a TM M and an input string x, let e(M) be the encoding of M. Does there exist an effective procedure (computable function) for deciding, for every pair (e(M), x) that does M halt for x?&lt;/p&gt;
&lt;p&gt;It is equivalent to ask whether the language L = {e(M)&amp;amp;s | M halts for s} is recursive (it is RE)?&lt;/p&gt;
&lt;p&gt;The proof of the unsolvability of many problems relies on the unsolvability of Halting problem.&lt;/p&gt;
&lt;h3&gt;Halting theorem: The Halting problem for Turing machine is unsolvable.&lt;/h3&gt;
&lt;p&gt;Assume the Halting problem is solvable, then there exists a Turing machine H that decides the Halting problem. If H can solve the Halting problem for input e(M)&amp;amp;x, H should be able to solve the Halting problem for input e(M)&amp;amp;e(M).&lt;/p&gt;
&lt;p&gt;Let H’ be a Turing machine that takes e(M) and makes a copies to obtain e(M)&amp;amp;e(M). Then the H’ execute H with the input e(M)&amp;amp;e(M), but in the case that M halts (that is H halts with yes), H’ loops forever.&lt;/p&gt;
&lt;p&gt;If the input of H’ is e(H’), then &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If H’ halts for e(H’), then H answers yes and H’ loops for ever.&lt;/li&gt;
&lt;li&gt;If H’ does not halts for e(H’), then H answers no and H’ halts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both give a contradiction. Neither H nor H’ exists, hence Halting problem is unsolvable.&lt;/p&gt;
&lt;p&gt;Note1: Halting theorem says for any fixed reasoning system, there are instances on which it fails. But NOT says, there are instances for which all reasoning systems fail.&lt;/p&gt;
&lt;p&gt;Note2: [WRONG] For any TM M and input, there does not exist a TM H decides whether M halts.
For a single pair of TM and input, there are always a TM that gives either yes or no, but we don’t know which one.&lt;/p&gt;
&lt;h3&gt;The general structure/technique of the prove: Self-reference with a twist.&lt;/h3&gt;
&lt;p&gt;In the uncountability of real number, we take the entries of diagonal and twist it by adding one to each entries. &lt;/p&gt;
&lt;p&gt;In the barber paradox, the problem is the self-reference with negation in defining the set of people shaved by the barber.&lt;/p&gt;
&lt;h3&gt;Decision Problems and Reduction&lt;/h3&gt;
&lt;p&gt;Decision problem can be states as a question of some formal system with yes/no answer.&lt;/p&gt;
&lt;p&gt;If the decision problem is solvable, then there exist a TM that for every instance of the problem, it halts with output yes or no.&lt;/p&gt;
&lt;p&gt;pi reduced to pi’ = An algorithm to solve pi’ can be directly used to solve pi. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If pi reduced to pi’ and pi’ is solvable then pi is solvable.&lt;/li&gt;
&lt;li&gt;If pi reduced to pi’ and pi is unsolvable then pi’ is unsolvable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Empty word halting problem&lt;/h3&gt;
&lt;p&gt;Give a TM M. Does M halt on epsilon? &lt;/p&gt;
&lt;p&gt;Proof: (1) show eHP reduced to HP. (2) Assume eHP is solvable. (3) HP is solvable -&amp;gt; contradiction.&lt;/p&gt;
&lt;p&gt;Assume an instance of HP, M and x; an instance of eHP, M’ and empty string e. M’ first write x onto its tape to simulate M. (eHP reduce to HP). If we can show M’ halts on e, then M halts. This is a contradiction to Halting theorem. Therefore, eHP is unsolvable.&lt;/p&gt;
&lt;h2&gt;3. NP-hardness and Reductions&lt;/h2&gt;
&lt;h3&gt;Polynomial time reduction and how reduction are used to show problems are in NP-complete&lt;/h3&gt;
&lt;p&gt;Given any instance of a problem class X.&lt;/p&gt;
&lt;p&gt;Computer an instance f(x) in problem class Y with the conversion done in polynomial time and the answer preserved, i.e., ans(x) = yes if fans(f(x)) = yes.&lt;/p&gt;
&lt;p&gt;To show NP-complete, we need to show NP-hard. If a problem is said to be NP-hard iff all problems in NP can be reduced to it in polytime.&lt;/p&gt;
&lt;h3&gt;Decision Problems&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem"&gt;SAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability"&gt;k-SAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[MONOTONE-k-SAT]&lt;/li&gt;
&lt;li&gt;[KNAPSACK]&lt;/li&gt;
&lt;li&gt;[BIN PACKING]&lt;/li&gt;
&lt;li&gt;[HAMILTONIAN CYCLE]&lt;/li&gt;
&lt;li&gt;[TSP(D)]&lt;/li&gt;
&lt;li&gt;[CIRCUIT SAT]&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Subset_sum_problem"&gt;SUBSET SUM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[NUMBER PARTITION]&lt;/li&gt;
&lt;li&gt;[GRAPH COLOURING]&lt;/li&gt;
&lt;li&gt;[INDEPENDENT SET]&lt;/li&gt;
&lt;li&gt;[CLIQUE]&lt;/li&gt;
&lt;li&gt;[VERTEX COVER]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Prove SAT is HP-hard(informal, read more on &lt;a href="http://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem"&gt;Cook-Levin Theorem&lt;/a&gt;)&lt;/h3&gt;
&lt;p&gt;If SAT is NP-hard, then every problem in NP can be reduced to SAT in polynomial time. &lt;/p&gt;
&lt;p&gt;According to the definition of NP problem, this means:&lt;br&gt;
Given an input s of size n, an arbitrary NDTM M that run in polynomial time p(n).&lt;/p&gt;
&lt;p&gt;We need to convert the NDTM and input into a SAT formula in polynomial time, such that the NDTM has an accepting computation if and only if the SAT formula has a satisfying assignment.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Using variables in the form of function of time t to describe states&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x(i, t) = 1 iff the machine in state i at time t  &lt;/li&gt;
&lt;li&gt;y(i, k, t) = 1 iff the tape element i has value k at time t  &lt;/li&gt;
&lt;li&gt;z(i, t) = 1 iff the head is at position i at time t  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If all values of these variables are given, then the execution sequence of NDTM is given.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The transition to reach state at time t + 1 only depends on state at time t and a non-determinism choice w(c, t) meaning choice c at time t.
These could be expressed using polynomial size clauses. &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The NDTM is converted into a polysize SAT formula containing variables describing the states as a function of time and allowing the need of non-determinism. The SAT formula has a satisfying formula iff there is some sequence of states of the NDTM that lead to acceptance.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(To be finished...)&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Computability</category><category>Notes</category><guid>http://www.jiaqili.me/en/posts/g53com-computability-1314-revision-notes.html</guid><pubDate>Sun, 01 Jun 2014 20:54:42 GMT</pubDate></item></channel></rss>