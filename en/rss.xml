<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Virtual World</title><link>http://www.jiaqili.me/</link><description>Jiaqi Li's personal blog.</description><atom:link href="http://www.jiaqili.me/en/rss.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Thu, 26 Nov 2015 17:13:07 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Java垃圾收集技术</title><link>http://www.jiaqili.me/en/posts/java-gc/</link><dc:creator>Jiaqi Li</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;这篇是对《深入理解Java虚拟机》的第三章的总结笔记，G1部分还没有细看&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1 判断对象存活与否&lt;/h3&gt;
&lt;h4&gt;1.1 引用计数器(没有GC使用)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;每当有一个地方引用对象时，数值就+1，引用失效时，数值就-1。&lt;/li&gt;
&lt;li&gt;问题是无法解决对象之间的循环引用问题，比如对象A的一个字段引用B，对象B的一个字段引用A，然后对象A和B被设置为null，这时无法回收A和B。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.2 可达性分析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从一系列GC Roots开始搜索，如果GC Roots到这个对象不可达时，则该对象是不可用的。&lt;/li&gt;
&lt;li&gt;GC Roots包括虚拟机栈中引用的对象，本地方法栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2 finalize()&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可达性分析后没有与任何GC Roots引用链相连接的对象，会被第一次标记；&lt;/li&gt;
&lt;li&gt;这些对象会被筛选是否需要执行finalize()方法：当对象没有覆盖finalize或者finalize已经调用过时，该方法就不会被执行，也就是说finalize最多只会执行一次对于任何一个对象；&lt;/li&gt;
&lt;li&gt;对于有必要执行finalize的对象，会被放到一个F-Queue的队列中，由一个虚拟机建立的低优先级线程去执行；&lt;/li&gt;
&lt;li&gt;在finalize方法中对象可以和引用链上的任何一个对象建立关联；&lt;/li&gt;
&lt;li&gt;之后GC会对F-Queue中的对象进行第二次标记，如果对象重新和引用链中的对象建立关联，则不会被回收。&lt;/li&gt;
&lt;li&gt;实践中，不要使用这个方法，因为不确定性的大，运行代价高。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3 永久代垃圾收集&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;废弃常量：没有任何String对象引用常量池中的某个常量，则它会被清理出常量池&lt;/li&gt;
&lt;li&gt;无用的类：该类所有实例都被回收，并且；加载该类的ClassLoader已被回收，并且；该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4 GC算法&lt;/h3&gt;
&lt;h4&gt;4.1 标记-清除算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来回收老年代。首先标记出所有需要回收的对象，然后统一回收所有被标记的对象。&lt;/li&gt;
&lt;li&gt;问题：两个阶段效率都不高，产生大量不连续的内存片段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.2 复制算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来回收年轻代内存。将年轻代划分为一块较大的Eden区，和两块较小的Suvivor区域。每次使用Eden和一块suvivor。当回收发生时，这两块区域的存货对象被全部复制到另一块suvivor区域，然后清理掉他们的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.3 标记-整理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来回收老年代内存。和标记-清除一开始一样，但它把所有被标记的存活对象移动到内存的一段，然后清理掉剩下的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.4 分代收集&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据年轻代和年老代的特点。年轻代每次回收都有大量对象死去，就使用复制算法；而老年代就使用标记-清理或标记-整理算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="heap.png" src="http://www.jiaqili.me/en/galleries/java-gc/heap.png" title=""&gt;&lt;/p&gt;
&lt;h3&gt;5 内存分配和回收策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对象一般先在eden中分配，如果启用了TLAB，则先在TLAB上分配，如果空间不够，虚拟机将发起一次Minor GC。&lt;/li&gt;
&lt;li&gt;需要大量连续空间的对象，比如数组或者很长的字符串。虚拟机有一个-XX: PretenureSizeThreshold参数，大于该值的对象直接进入老年代分配。&lt;/li&gt;
&lt;li&gt;对象在Eden被分配内存，经历第一次Minor GC后仍旧存货，并被幸存者空间容纳，对象年龄就设置为1，之后没经历过一次Minor GC年龄就+1，默认在年龄超过15时就进入老年代。这个值可以在-XX:MaxTenuringthreshold中设置。&lt;/li&gt;
&lt;li&gt;如果在幸存者空间中相同年龄所有对象大小的综合大于幸存者空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/li&gt;
&lt;li&gt;空间分配担保：&lt;/li&gt;
&lt;li&gt;在进行Minor GC前，虚拟机先检查老年代可用的连续空间是否大于新生代所有对象总空间，如果大于，则此次回收是安全的（因为即使所有对象都要进入老年代，也有足够的空间）；&lt;/li&gt;
&lt;li&gt;如果不是，则检查HandlePromotionFailure设置是否允许失败担保，如果允许，再检查老年代最大可用的连续空间是否大于历次进入老年代对象的平均大小，如果大于，则进行一次Minor GC，尽管可能是有风险的；如果小于，或者不允许失败担保，则进行一次Full GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6 垃圾收集器&lt;/h3&gt;
&lt;p&gt;&lt;img alt="gc.jpg" src="http://www.jiaqili.me/en/galleries/java-gc/gc.jpg" title=""&gt;&lt;/p&gt;
&lt;h4&gt;6.1 Serial收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单线程，它进行垃圾收集的时候，必须暂停其他所有工作线程，直到它结束&lt;/li&gt;
&lt;li&gt;虚拟机运行Client模式下默认的新生代收集器，采用复制算法；&lt;/li&gt;
&lt;li&gt;优点：简单高效，单线程收集没有线程交互的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.2 ParNew 收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Serial的多线程版本（并行收集器：多个垃圾收集线程一起工作，但是用户线程仍旧暂停），但是单CPU环境下不会比Serial有更好的效果，随着CPU数量的增加，能增加GC时对系统资源的有效利用；；&lt;/li&gt;
&lt;li&gt;虚拟机Server模式下的新生代首选收集器，仍旧采取复制算法，&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.3 Parallel Scavenge 收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同ParNew是一个并行收集器，采用复制算法；&lt;/li&gt;
&lt;li&gt;目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间)），适合在后天运算不需要太多交互的任务。&lt;/li&gt;
&lt;li&gt;两个参数用于控制吞吐量：最大垃圾收集停顿时间-XX:MaxGCPauseMills；吞吐量大小-XX:GCTimeRatio;&lt;/li&gt;
&lt;li&gt;缩短最大停顿时间，是以牺牲吞吐量和缩小新生代空间来换取的，比如收集一个较小的新生代总比较大的新生代的时间要短；&lt;/li&gt;
&lt;li&gt;这个收集器还有自适应调整新生代大小，eden和suvivor比例，老年代晋升年龄的机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.4 Serial Old 收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Serial的老年代版本，单线程，标记-整理算法；&lt;/li&gt;
&lt;li&gt;主要给Client模式下的虚拟机使用，在Server模式下与Parallel Scavenge配合使用，或者作为CMS的后备方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.5 Parallel Old 收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Scavenge 的老年代版本，标记-整理算法；&lt;/li&gt;
&lt;li&gt;同样是注重吞吐量和CPU资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.6 CMS - Concurrent Mark Sweep&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;并发收集器（用户线程和垃圾收集线程交替执行，之前多线程的都是并行），目的在于缩短停顿时间，标记-清除算法；&lt;/li&gt;
&lt;li&gt;初始标记(initial mark): 仅标记GC Root能直接关联到的对象，速度很快，但是单线程工作，并且用户线程暂定；&lt;/li&gt;
&lt;li&gt;并发标记(concurrent mark): 进行GC Root Tracing，GC线程和用户线程同时运作；&lt;/li&gt;
&lt;li&gt;重新标记(remark):修正并发标记期间，用户线程行为导致标记产生变动的那一部分对象的标记记录；多线程重现标记，但是用户线程暂定；&lt;/li&gt;
&lt;li&gt;并发清除(concurrent sweep):清除，和用户线程同时运作；&lt;/li&gt;
&lt;li&gt;其中并发标记和并发清除需时最长，但是可以和用户线程同时工作；因此CMS的特点是并发收集，低停顿；&lt;/li&gt;
&lt;li&gt;缺点1：并发阶段需要占用CPU时间，而导致程序运行减慢，总吞吐量降低；&lt;/li&gt;
&lt;li&gt;缺点2：因为采用标记-清除而不是标记-整理算法，所以会产生大量零散空间，当没有足够的连续空间来分配大对象是，必须触发Full GC；&lt;/li&gt;
&lt;li&gt;缺点3：垃圾收集阶段用户线程的运行带来的问题：1. 不能等老年代全部满时再进行收集，因为要预料一部分空间提供并发收集时程序的运作，而当此预留内存无法满足程序需要时，就会发生Concurrent Mode Failure，这是将启用后备的Serial Old收集器来处理老年代，导致停顿时间很长；2. 并发清理阶段程序还在运行，就会产生新的垃圾，这部分垃圾出现在标记过程之后，需要等待下一次GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.7 Garbage First (G1)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;整个Java堆被划分成了多个大小相等Region，新生代和老年代不再是连续的，每个region可以属于新生代也可以属于老年代；&lt;/li&gt;
&lt;li&gt;G1收集器可以建立可以预测的停顿模型，因为它有计划地避免在整个Java堆中进行全区域的垃圾收集，它跟踪各个Region里面的垃圾堆的价值大小，维护一个优先列表，每次根据允许的时间，优先回收价值最大的Region，这也是名称的由来。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>http://www.jiaqili.me/en/posts/java-gc/</guid><pubDate>Thu, 26 Nov 2015 16:00:00 GMT</pubDate></item><item><title>Java动态内存分配</title><link>http://www.jiaqili.me/en/posts/dynamic-memory-allocation/</link><dc:creator>Jiaqi Li</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;这篇是对《深入理解Java虚拟机》的第二章的总结笔记&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1 运行时数据区 (Runtime Data Areas)&lt;/h3&gt;
&lt;h4&gt;1.1 Java堆  (Java Heap)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机启动时创建，&lt;strong&gt;线程独立&lt;/strong&gt;：所有线程共享；&lt;/li&gt;
&lt;li&gt;目的是存放对象实例和数组，几乎所有对象都在堆中分配内存；&lt;/li&gt;
&lt;li&gt;垃圾收集器的管理的主要区域，又叫GC堆；&lt;/li&gt;
&lt;li&gt;因为GC大多采用分代收集算法，堆又可以分成&lt;strong&gt;新生代&lt;/strong&gt;和&lt;strong&gt;老年代&lt;/strong&gt;，新生代又可分为&lt;strong&gt;伊甸园&lt;/strong&gt;，&lt;strong&gt;幸存者空间1&lt;/strong&gt;，&lt;strong&gt;幸存者空间2&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;堆在物理上可以是在不连续的空间，但是逻辑上是连续的；&lt;/li&gt;
&lt;li&gt;主流虚拟机的堆是可扩展的（JVM标准规定可以实现成固定大小的），通过-Xmx/-Xms决定，如果堆中内存不足以分配实例，且不能扩展，就会抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.2 方法区 (Method Area)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程独立&lt;/strong&gt;：所有线程共享；&lt;/li&gt;
&lt;li&gt;目的是存放类信息，常量，静态变量，二进制字节码的代码，HotSpot虚拟机加载类的时候创建的类对象也存放于此；&lt;/li&gt;
&lt;li&gt;HotSpot用GC管理此区域，也叫做&lt;strong&gt;永久代&lt;/strong&gt;，GC主要进行常量池的回收和对类型的卸载；&lt;/li&gt;
&lt;li&gt;无法满足内存分配需求是抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;li&gt;其中有&lt;strong&gt;运行时常量池&lt;/strong&gt;，Class文件中的常量池（包括字面量和符号引用）将在类被加载后进入运行时常量池；运行时常量池通常还会储存解析后的直接引用；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3 程序计数器(Program Counter Register)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;线程隔离：每个线程独立使用；&lt;/li&gt;
&lt;li&gt;用于指示当前线程所执行字节码的行号；&lt;/li&gt;
&lt;li&gt;如果当前线程在执行一个Java方法，则它记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，则是未定义的。&lt;/li&gt;
&lt;li&gt;Java多线程由线程切换并分配处理器时间的方式实现，因此为了恢复线程到上次执行的位置，每个线程需要有独立的程序计数器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.4 Java虚拟机栈（VM Stack）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;线程隔离：每个线程独立使用；&lt;/li&gt;
&lt;li&gt;每个方法在执行时都会创建一个栈帧，用于储存局部变量表（编译期间确定大学，运行时不变），操作数栈，动态链接，方法出口灯，一个方法的调用到结束，对应着一个栈帧在虚拟机栈的入栈到出栈的过程；&lt;/li&gt;
&lt;li&gt;请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常，如果虚拟机允许动态扩展，但是无法申请到足够内存，就会抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.5 本地方法栈(Native Stack Method)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同Java虚拟机栈，前者为Java方法也就是字节码服务，本地方法栈为Native方法服务；&lt;/li&gt;
&lt;li&gt;异常同虚拟机栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2 对象的创建&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机遇到new指令时，先检查这个指令的参数能否在常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有则进行&lt;strong&gt;类加载过程&lt;/strong&gt;（见类加载机制）；&lt;/li&gt;
&lt;li&gt;分配内存。&lt;/li&gt;
&lt;li&gt;划分可用空间问题。指针碰撞(Bump the Point)方法：Java堆中内存是绝对规整的，也就是GC是带有压缩整理功能的，比如Serial, ParNew；空闲列表(Free List)：虚拟机维护一个列表记录哪些内存块是可用的，GC并不压缩整理，比如CMS这种基于mark-sweep的。&lt;/li&gt;
&lt;li&gt;内存分配动作的线程安全问题。同步处理：采用CAS加上失败重试来保证原子性；使用本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，线程在各自的TLAB上分配内存，在TLAB用完需进行性的TLAB分配时才需要同步锁定。&lt;/li&gt;
&lt;li&gt;将分配的内存空间初始化为零值。&lt;/li&gt;
&lt;li&gt;对对象进行设置，比如对象的哈希码，GC分代年龄信息，属于哪个类的实例等，这些都放在对象头(Object Header)中。&lt;/li&gt;
&lt;li&gt;执行&lt;init&gt;对象构造器方法。&lt;/init&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3 对象的内存布：分为对象头，实例数据和对其填充&lt;/h3&gt;
&lt;h4&gt;3.1 对象头&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Mark Word：一个32位或者63位的信息，取决于虚拟机是32位还是64位。储存包括哈希码，GC分代年龄，锁状态标志，线程所持有的锁，偏向线程ID，偏向时间戳等。它被设计成一个非固定数据结构，可以根据对象不同状态复用自己的储存空间。&lt;/li&gt;
&lt;li&gt;类型指针：指向类元数据的指针，用来确定对象是哪个类的实例；&lt;/li&gt;
&lt;li&gt;如果是数组，则还要记录长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.2 实例数据&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;包括从父类继承的和子类中定义的；&lt;/li&gt;
&lt;li&gt;储存顺序受虚拟机分配策略参数和字段在源代码中定义的顺序影响：&lt;/li&gt;
&lt;li&gt;HotSpot为longs/doubles, ints, shorts/chars, bytes/booleans, ordinary object pointers&lt;/li&gt;
&lt;li&gt;在满足上述条件下，父类中定义的变量出现在子类之前；&lt;/li&gt;
&lt;li&gt;如果CompactFields被设置，子类中较窄的变量也可能插入到父类变量的空隙中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.3 对象填充&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HotSpot要求对象起始地址必须为8字节的整数倍，对象头正好是8字节的倍数（1倍或2倍），如果实例数据没有对齐，则需要填充。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4 对象访问：通过栈上的reference数据来操作堆上的具体对象，访问具体对象的方法分为：&lt;/h3&gt;
&lt;h4&gt;4.1 句柄&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;堆中划分出一块空间用来作为句柄池。栈中的reference指向句柄地址，两个句柄指针分别指向对象实例地址（在堆中）和对象类型数据地址（在方法区中）。这种定位对象的好处是reference比较稳定，当GC时，对象很可能会被移动，这只要改变句柄中的实例地址指针就可以，reference不需要修改；不好的地方是需要进行两次定位，有额外开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.2 直接指针访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;reference储存的直接就是对象在堆中的地址，对象空间再保存类型数据地址。好处是找到对象只需要进行一次指针定位。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5 虚拟机参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;-Xms 堆最小值，比如-Xms20m表示堆最小值为20MB；&lt;/li&gt;
&lt;li&gt;-Xmx 堆最大值，将-Xms和-Xmx设置成相同可以避免堆自动扩展；&lt;/li&gt;
&lt;li&gt;-Xss栈容量&lt;/li&gt;
&lt;li&gt;-MaxPermSize最大方法区容量&lt;/li&gt;
&lt;li&gt;操作系统内存限制-Xmx-MaxPermSize剩下的就被分给了栈和本地方法栈，可以通过减少最大堆和减少栈容量来换取更多线程。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>http://www.jiaqili.me/en/posts/dynamic-memory-allocation/</guid><pubDate>Thu, 26 Nov 2015 15:40:00 GMT</pubDate></item><item><title>英国计算机研究生申请</title><link>http://www.jiaqili.me/en/posts/taught-master-in-computer-science-application/</link><dc:creator>Jiaqi Li</dc:creator><description>&lt;div&gt;&lt;p&gt;作者：&lt;a href="http://www.jiaqili.me/"&gt;Jiaqi Li&lt;/a&gt;  |  授权方式：&lt;a href="http://creativecommons.org/licenses/by-nc-nd/4.0/"&gt;CC BY-NC-ND 4.0&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;0. 背景&lt;/h2&gt;
&lt;p&gt;这篇文章主要针对宁诺学生，介绍的是英国计算机授课型研究生的申请，特别是牛津和帝国理工，部分内容也可能适用于其他地区、学校和专业。申请时间是1314学年，请注意时效性，一切以官网为准。&lt;/p&gt;
&lt;h2&gt;1. 从大一到大三&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;大三结束的同学可以跳过&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1.1 选课&lt;/h3&gt;
&lt;p&gt;选课的时候可以考虑主修方向，个人兴趣和难易程度。 &lt;/p&gt;
&lt;p&gt;首先，如果明确自己以后要学什么，可以将选修课程的大部分集中在那个区域里，你的PS和成绩单会非常有说服力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;比如计算机图形，可以学一下Computer Graphics, Introduction to Image Processing, Computer Vision等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比如机器学习，可以学一下Introduction to Modelling and Optimisation, Machine Learning, Data Mining Techniques and Applications等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再比如系统网络方向，Computer Communications and Networks, Advanced Computer Communications, Parallel and Distributed Computing, Computer Security, Operating Systems, Concurrency, Connected Computing at Scale等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AI方向有Knowledge Representation and Reasoning, Autonomous Robotic Systems, Designing Intelligent Agents, AI Programming Techniques；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有HCI方向的Graphical User Interfaces, Human Computer Interaction, Collaboration and Communication Technologies 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这只是一个建议，并不是严格的分类，课程本身都有交叉。另外，如果涉及到数学基础很强的方向，比如机器学习，建议选一些数学学院或者工程学院下面的数学课，宁诺计算机教的数学真是完全不行（真的有教过？）。如果没有明确方向的话，其实也没关系。本科阶段最好多涉猎一点各方面的内容，特别在前两三年，知识的广度比深度更重要。&lt;/p&gt;
&lt;p&gt;除了主修方向以外，其他的课程可以按照自己的兴趣来选。第一，感兴趣的课程一般容易学，容易拿分；第二，如果一学期这么多课里一门都不喜欢，读书一定很痛苦。&lt;/p&gt;
&lt;p&gt;最后的难易程度直接涉及到分数问题。每年因为课程大纲的变化，任课老师的变动，都有一些课容易拿分，有些则很难。除了问学长学姐以外，每学期开始一两周都是可以试听的，所以每门课都去听一下，感受一下，也可以直接问老师关于分数的问题，他们也是过来人，一般愿意回答。&lt;/p&gt;
&lt;h3&gt;1.2 成绩&lt;/h3&gt;
&lt;p&gt;虽然只有大三大四的成绩会决定你的学位等级，并且申研时最重要的是大三成绩，但是剑桥要求提供所有成绩，牛津，帝国也可能被要求大一和大二的成绩。其中和所申请专业有关系的科目的成绩比较重要，但也会看你大一的英语成绩。&lt;/p&gt;
&lt;p&gt;英国授课型研究生的申请最简单的玩法是看成绩，复杂玩法包括很牛的推荐人，发表过论文，参加国际比赛比如ACM-ICPC并且拿奖，在比如微软亚洲研究院实习等等。如果复杂的玩不好，请努力提高成绩。开始申请前，大三的成绩基本上决定了你能申请到什么样的学校。&lt;/p&gt;
&lt;p&gt;对于申请牛剑帝，如果没有到70，录取机会比较小，但也有成功的例子。分数在75分以上，其他部分（比如面试，PS，推荐信等后文会介绍）不出问题，基本上可以进至少一所。分数更高一点，可以弥补个别材料的瑕疵，比如PS，CV，面试等。&lt;/p&gt;
&lt;p&gt;对于UCL，要求60以上。有50+录取的例子，也有70被拒的。取决于具体专业，有些比较热门；也取决于你的专业是否和你所学知识对口。&lt;/p&gt;
&lt;h2&gt;2. 大三暑假&lt;/h2&gt;
&lt;p&gt;如果你想去美国，暑假里或更早的时候，应该把GRE考掉（MIT不需要，有志于MIT的同学可以试一下）。&lt;/p&gt;
&lt;p&gt;这篇文章假设你的申请目标是英国，没有GRE，但是根据你的情况可能需要雅思。如果你是2+2项目，基本上没有学校会问你要语言成绩，至少牛剑帝不需要，不排除个别学校比如据说爱丁堡还是要雅思，也不排除因为自身原因被con雅思。但你可以去试一下自己的英语水平，一个不错的成绩（雅思各项7+）对申请会有加分。如果你是4+0，牛剑基本上各项都要7+，帝国可以低一点，请参考官网。建议大三暑假前考出，大四会比较忙，或者到拿到offer后再考，压力会大一点。&lt;/p&gt;
&lt;p&gt;暑假里成绩出来以后，给自己定位一下，选5所理想的学校，每个学校选好专业。如果你不打算美国这条路，剩下的就是英国，香港，加拿大，新加坡，澳洲这些地方的学校都可以进入你的考虑范围，但是整体数量也不多。牛剑9月份开放申请，帝国11月份开放申请，截止日期一般到3月份，之后名额就很少或者没有了。英国的其他学校申请时间都很长，有些甚至7月份还有名额。但是香港，加拿大等其他国家很多高校截止较早，如果有兴趣，请关注他们的官网。
假设你的大三成绩在75+，一般首选英国排名前三的学校，再加一两所保底，如果因为其他原因，比如就业、移民等特别想去某个地方的，也可以考虑新加坡、澳洲等高校。70-75一般冲一下前三，但很可能进UCL，这个分数申请香港各高校均没问题。60-70基本上把精力放在UCL这个档次上，同时也可以考虑布里斯托，爱丁堡，南安普顿等英国计算机比较好的学校。50-60可以考虑本校。&lt;/p&gt;
&lt;p&gt;有了定位以后，可以准备一下自己的申请材料——PS和CV（下文具体讲）。我自己假期里考了个雅思，看了些学校的信息，其他的东西，比如材料准备，都是到10月份之后才开始的。所以，所以实践证明，大四开学后（来英国以后）再开始准备是可行的。甚至某同学圣诞节才开始写PS。&lt;/p&gt;
&lt;p&gt;加一段比较主观的内容。不要找中介。中介唯一能做的事情就是写PS，接下来会介绍如何写。中介还能做什么，填申请表？没任何难度，都是个人信息。找老师写推荐信？自己一封邮件可以搞定。面试？学校Career的外教给你提供模拟面试训练（虽然我没有试过）。签证？2+2同学都签过，4+0同学请咨询你们的校友。总之，我觉得中介是挺浪费钱的，除了可能会给你省时间。&lt;/p&gt;
&lt;h2&gt;3. PS&lt;/h2&gt;
&lt;p&gt;PS是可能是所有材料里最开放的，准备时间最长的东西。最重要的是内容，其次是结构，这些做的好能给你加分，不好会减分；文采，语法，拼写，标点，排版等等都是相对次要的。一个合格的PS应该是：当老师读完以后，即便没有见过你，但是他的脑子里已经得有你这个人的生动的形象了，并且这个形象符合他们录取标准。所以PS要真实，具体，突出自己的特点。一般不会写自己的缺点，或做的不好的地方，除非你是用它来反衬出自己某些品质，比如因为勤工俭学，导致影响了成绩，但是最后还是如何如何。&lt;/p&gt;
&lt;h3&gt;3.1 PS的内容&lt;/h3&gt;
&lt;p&gt;有些学校对PS内容有要求，比如牛津和UCL，那就一定按照要求来。他们要你写的地方你都要照顾到，但不是列举，而是渗透到文章中，并从文章中体现出来。比如你想要表达自己善于快速思维，解决问题。就可以用具体的例子，比如参加学校某个活动，做了哪些事情。如果没有要求，一般可以cover到这些点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你为什么选择这个学校？这个专业？你的未来规划是什么？&lt;/li&gt;
&lt;li&gt;你的motivation是什么？为什么你觉得你能胜任这个课程？&lt;/li&gt;
&lt;li&gt;你是否有commitment来完成这个课程？&lt;/li&gt;
&lt;li&gt;你的特点，个性是否符合我们的期望？&lt;/li&gt;
&lt;li&gt;你希望从这个课程中得到什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请用具体的经历来反应出上面的很多问题，不要枚举，也不要写成散文。别忘了PS是体现你这个“人”的，如果你的PS读完以后，感觉和CV一样的话，那基本就废了。另一点就是，凡是CV和Transcript上提到的东西，PS没有展开来写的就不要点到了。&lt;/p&gt;
&lt;p&gt;不要讲故事，的确有很多模板是以故事开头的，而且的确写的很好，但是：“我从就喜欢计算机……”，然后扯上一段。除非你的英语能力达到了能够使人听了以后非常信服的程度，不然听上去真的像故事。&lt;/p&gt;
&lt;p&gt;有些学校对PS长度有要求。要求多长就不要超过。没有要求的一般写两页以内。&lt;/p&gt;
&lt;p&gt;对于有面试的申请，不要把自己吹的很高，你的PS将成为你的面试题！对于没有面试的申请，也要真实，没有Evidence的东西尽量少讲，撒谎更是可耻的，材料是记录在案的，就算毕业了，后来被发现申请材料有假，可能也会被取消学位。&lt;/p&gt;
&lt;p&gt;所以写PS可能就一两天，但是准备得一两周。你一定要把自己的经历，能力，特色好好的梳理一下（大学以前的事情就不必提了）&lt;/p&gt;
&lt;h3&gt;3.2 PS的结构&lt;/h3&gt;
&lt;p&gt;PS一般没有固定结构，仅供参考。&lt;/p&gt;
&lt;p&gt;第一段可以写为什么申请这个学校，为什么申请这个专业，我的motivation和我的职业规划。注意衔接，比如说要让人感觉你有明确的motivation，所以你有清晰的目标，为了这个目标，你们学校这个专业是我的最佳选择。&lt;/p&gt;
&lt;p&gt;第二-三段可以写你本科阶段所学的知识。可以把理论和实践分开来讲，也可以按想关科目讲。但是千万别写成CV了，“我学过这个，我知道那个…”。实际上你要回答一个问题“为什么我能胜任这个课程？”答案是“你看，我有这些这些背景”，而你的表述得生动一点，比如你可以通过自己的motivation把这些串起来，或者其他什么方式。你甚至不必提你具体的课，只是让老师知道你学过这些想关知识就可以了。这里内容不在多，而在精，只讲有帮助的。&lt;/p&gt;
&lt;p&gt;第三部分你可以讲自己做过的项目（如果和所申请专业相关），每个人至少做过一个项目，比如你大三你在项目组里担任什么角色，用了什么技术，遇到什么问题，你是如何解决，怎么体现了自己的能力，特点。&lt;/p&gt;
&lt;p&gt;第四部分可以讲课堂外的经历（如果和所申请专业相关），实习，参加竞赛，发表论文，做项目等等只要能体现出对方想要的东西，你就可以加进来。还是不在多而在精&lt;/p&gt;
&lt;p&gt;第五部分可以讲希望从课程中得到什么（表示自己的期望和你们的课程是相符合的），体现下自己的commitment，做个收尾。&lt;/p&gt;
&lt;p&gt;你完全没必要按照我的建议写，甚至我希望你不要因为这个样板而受到拘束。PS是灵活的东西，几乎没有一篇PS是一样的。还是那个词要体现出你的特点（这个模板用的人多了，肯定会成为一个糟糕的模板）。
但是要注意，有些东西你的内容中表现不出来，需要从你的行文中表现。比如你的逻辑思维能力。这考验你CELE的课有没有学好。比如说一段话第一句总起，第二句解释，第三句举例等等。用好连接词，把文章条理弄清楚。总体上来说，很多一部分会是你的个人经历。所以之前的准备工作很重要，之后就是把你搜集出来的各种“相关”经历组织成文，然后加工使她变的符合要求，继而读起来流畅，最后变的生动。&lt;/p&gt;
&lt;h3&gt;3.3 PS的其他&lt;/h3&gt;
&lt;p&gt;虽然排版，语法等等不重要，不用强求，但也请把他们做到你能力范围内的最好。&lt;/p&gt;
&lt;p&gt;排版用LaTex，谷歌之（或者至少要达到CELE交作业的要求）。&lt;/p&gt;
&lt;p&gt;文采靠英语水平，不是一时半会儿能提高的，但是找几篇样本（外国人写的，被Oxbridge录取的）来参考会有很大帮助。&lt;/p&gt;
&lt;p&gt;语法，拼写，标点。请自己和朋友帮忙多读几遍（下面会讲怎么校对）。&lt;/p&gt;
&lt;h3&gt;3.4 PS的修改校对&lt;/h3&gt;
&lt;p&gt;慢慢改，你的第一篇PS需要花最多的时间。从第一稿到完稿中间可能有十几搞，也可能只是读了一遍。但是一般你的第二篇、第三篇PS会很快。&lt;/p&gt;
&lt;p&gt;学校的Career Service或者Academic Clinic Service能看内容结构语法，但是不会给你看的很仔细。他们对于语言问题上的建议，可以重视；内容和结构要自己拿主意。&lt;/p&gt;
&lt;p&gt;自己的Supervisor/Tutor。他们一般都是这个领域的专家，你的PS中涉及的技术问题，有没有不当的地方他们都知道。而且作为过来人，他们也有写这个的经验。找他们改PS是首选，他们的建议不管是内容，结构还是语法（如果是Native Speaker）上都有很大参考作用。但是注意，他们没有义务给你改，请你好好和他们说。&lt;/p&gt;
&lt;p&gt;最后找翻译公司。打印成双面A4一张，翻译公司会给你很仔细的看有没有语法，拼写，标点错误。他们完全不会给你内容上的建议，但是毕竟也是专业人士，语言上的建议可以参考。每次收费就50左右，相比中介几千块上万块就很便宜了。&lt;/p&gt;
&lt;h2&gt;4. CV&lt;/h2&gt;
&lt;p&gt;CV算是最简单的东西，暑假里也可以把CV写好。模板网上有很多，这个相对排版比较重要。可以参加宁波Academic Clinic Service的相关讲座，有帮助。除非你有paper发过，一般不要超过1页。一般可以包括以下内容，按是时间顺序从后到前。
1. 大学及之后的教育经历， 如果有相关课程，也加上。
2. 获得的荣誉
3. 做过的项目，发过的paper
4. 学术上的经历
5. 工作经历
6. 课外活动
7. 技能&lt;/p&gt;
&lt;h2&gt;5. 推荐信&lt;/h2&gt;
&lt;p&gt;找老师写推荐信的原则是，他越熟悉你越好，而不是他职位越高越好。有一个特例是，那个老师在你申请的学校有一定的威望，会有帮助。哪个老师对你了解，完全取决于你。但是一般都会要你最后一年的Supervisor写其中一封。除了Supervisor以外，你还可以找Personal Tutor。他是有义务给你写的，不会拒绝你。其他带过你的老师，比如大三小组项目的老师，也可以找。其他给你上过课的老师，你成绩不错，或者你提问题很多，他记得你的等等也可以找。&lt;/p&gt;
&lt;p&gt;有些老师推荐信写的很快，等你注册他名字后，两个小时就交掉了。有些老师写的比较慢，可能要一个多月。建议留足足够的时间，4-5个礼拜如果不是很急。我觉得这是对老师的尊重吧。就算很急也要说明原因，给几个礼拜的时间写。没有一个礼拜内就要的。&lt;/p&gt;
&lt;p&gt;如何问老师推荐信，参考这篇文章：&lt;a href="http://www.wikihow.com/Ask-Your-Professor-for-a-Letter-of-Recommendation-Via-Email"&gt;How to Ask Your Professor for a Letter of Recommendation Via Email&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6. 申请&lt;/h2&gt;
&lt;p&gt;有些学校九月份开放申请，有些则要等到十一月，请保持关注。申请的原则都是越早越好。&lt;/p&gt;
&lt;p&gt;开放申请以后可以先开始填申请表，不管你有没有PS或者CV。只有剑桥那个系统是要在大概一个月里面都填好的，其他其他学校应该没有时间限制。你可以慢慢写PS，等推荐信。&lt;/p&gt;
&lt;p&gt;如果开学后还没有PS（Research Proposal）和CV，不用急，慢慢开始写吧。等你有了这些文书以后，就开始准备推荐信吧。&lt;/p&gt;
&lt;p&gt;有了PS或者RP，CV，推荐信，填好申请表格就可以提交了。有些学校要提交以后才能给老师提交推荐信的链接，比如UCL。有些学校允许你先提交，然后再等老师推荐信，比如OX和IC。申请表填仔细不要出错。等你按下提交以后，就Out of your hand了。可以休息一下了。&lt;/p&gt;
&lt;h2&gt;7. 面试&lt;/h2&gt;
&lt;p&gt;只有牛津、剑桥、帝国有面试。帝国是连续的审核，如果你提交的早，比如一开放申请没多久就交掉了，那么人少，审核的快，可能一个多礼拜就能有面试通知。牛津是等一批结束以后一起审核，它给出了明确的面试时间（即你知道申请结果的时间前一两周）。不需要面试的其他院校，等你交了表格以后就没你什么事了。&lt;/p&gt;
&lt;h3&gt;7.1 牛津面试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;电话面试，一般15-30分钟，迟到1-3分钟他打过来；&lt;/li&gt;
&lt;li&gt;一开始会寒暄一下，主要是问你将来打算。&lt;/li&gt;
&lt;li&gt;很快进入正题，所有的问题都是技术性的。&lt;/li&gt;
&lt;li&gt;如前文所说，你的PS是最好的面试题，考官喜欢从里面找东西问你，确保你所写的你都掌握，并且能在几秒钟之内答上来。&lt;/li&gt;
&lt;li&gt;另一个是Transcript里的课也是面试题。凡是涉及理论的课，特别是排序算法，图算法，Machine and Language，AI要准备好。&lt;/li&gt;
&lt;li&gt;每个人问的都不一样，取决于你的申请方向（PS）和你所学（Transcript），看网上的经验没用。&lt;/li&gt;
&lt;li&gt;准备好介绍做过的项目，和你的主要经历。&lt;/li&gt;
&lt;li&gt;有的面试官喜欢问概念，有的则完全不问；有的喜欢让你举例子，比如说举一个图灵机不接受的语言；有的让你比较算法的好坏；&lt;/li&gt;
&lt;li&gt;你要在5秒钟内答出来，至少你要不停的讲你的思路，不然超过5秒的停顿，对方会认为你不懂，继而给你提示。&lt;/li&gt;
&lt;li&gt;很多很快得到Offer的面试都在15分钟左右结束了，超过20分钟的面试，一般是你回答的太慢，或者对方想多测试一下你的能力，再做定夺。&lt;/li&gt;
&lt;li&gt;不会让你做个人介绍，也似乎没有人问到你为什么来牛津？这种常见问题。&lt;/li&gt;
&lt;li&gt;好好复习你学过的所有理论专业知识。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;7.2 帝国面试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当面面试，一对一，时间比较长，40-45分钟。&lt;/li&gt;
&lt;li&gt;不会有技术问题, 但是会问你想学什么方向，最好之前研究下他们的官网。&lt;/li&gt;
&lt;li&gt;会让你选一下你想学的课程，为什么选这些。&lt;/li&gt;
&lt;li&gt;会让你介绍你做过的项目。&lt;/li&gt;
&lt;li&gt;帝国面试，比较随意，不建议穿正装，比较像聊天。&lt;/li&gt;
&lt;li&gt;帝国给面试的基本都录取了，牛津申请的基本都给面试了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;8. 录取率&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;牛津MSc in Computer Science 12-13年申请人数是285人，13-14年录取名额是75。&lt;/li&gt;
&lt;li&gt;帝国MSc计算机方面所有小专业，申请人数过千，录取一百多。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>http://www.jiaqili.me/en/posts/taught-master-in-computer-science-application/</guid><pubDate>Wed, 23 Jul 2014 20:43:42 GMT</pubDate></item><item><title>G53COM Computability Revision Notes</title><link>http://www.jiaqili.me/en/posts/g53com-computability-revision-notes/</link><dc:creator>Jiaqi Li</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;Contents based on G53COM lecture slides 1314 by &lt;a href="http://www.cs.nott.ac.uk/~ajp/"&gt;Dr Andrew Parkes&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;These are &lt;strong&gt;NOT&lt;/strong&gt; sample answers. Any definition, explanation or example listed below could be imprecise or incorrect. Please refer to your own notes and lecture slides.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;1. Definitions&lt;/h2&gt;
&lt;h3&gt;Problem Classes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NC&lt;/strong&gt; is a set of problem that can be solved in polylog time using polynomial a number of processors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DTIME(f(n))&lt;/strong&gt; is a set of problem that can be solved using some DTM in time f(n).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P = U&lt;sub&gt;k&lt;/sub&gt; DTIME(n&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; is a set of problem that can be solved using a DTM in any polynomial time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P-hard&lt;/strong&gt;: if a problem X is said to be P-hard iff all problems within P can be reduced to X using polylog time on a polynomial number of processors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P-complete&lt;/strong&gt;: if a problem X is said to be P-complete iff it is in P and it is P-hard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NTIME(f(n))&lt;/strong&gt; is a set of problem that can be solved using some NDTM in time f(n).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP = U&lt;sub&gt;k&lt;/sub&gt; NTIME(n&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; is a set of problem that can be solved using some NDTM in any polynomial time. A language is accepted by a NDTM is a set of strings that there exists one or more than one execution path of NDTM that gives yes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reduction from X to Y&lt;/strong&gt;: convert any instance of X to some instance of Y.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP-hard&lt;/strong&gt;: if a problem X is said to be NP-hard iff any problem in NP can be reduced to X in polynomial time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP-complete&lt;/strong&gt;: if a problem X is sad to be NP-complete iff it’s in NP and it’s NP-hard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSPACE(f(n))&lt;/strong&gt; is a set of problem that can be solved using some DTM with space f(n).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PSPACE = U&lt;sub&gt;k&lt;/sub&gt; DSPACE(n&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; is a set of problem that can be solved by a DTM using polynomial space.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PSPACE-hard&lt;/strong&gt;: if a problem X is said to be PSPACE-hard iff any problem in PSPACE can be reduced to X within polynomial time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PSPACE-complete&lt;/strong&gt;: if a problem is PSPACE-complete if it is in PSPACE and it is PSPACE-hard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSPACE(f(n))&lt;/strong&gt; is a set of problem that can be solved using some NTDM with space f(n).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NPSPACE = U&lt;sub&gt;k&lt;/sub&gt; NSPACE(n&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; is a set of problem that can be solved using a NTDM with polynomial space.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Relationship&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NC ⊆ P ⊆ NP ⊆ PSPACE = NPSPACE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;P ⊆ PSPACE&lt;/strong&gt;, because a poly time TM cannot use more than polyspace (space can be reuse, but time cannot). &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP ⊆ PSPACE&lt;/strong&gt;, a NDTM can be seen as an execution tree with polynomial height, any one execution path has a length of at most polynomial time. We can solve NP problem in PSAPCE by using DFS to explore the tree of possible executions due to non-determinism. Hence NP in PSPACE. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Savitch’s theorem&lt;/strong&gt;: NSPACE(f(n)) ⊆ DSPACE(f(n)&lt;sup&gt;2&lt;/sup&gt;)  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prove PSPACE = NPSPACE&lt;/strong&gt;&lt;br&gt;
      NSPACE(f(n)) ⊆ DSPACE(f(n)&lt;sup&gt;2&lt;/sup&gt;) by Savitch&lt;br&gt;
      NPSPACE = U&lt;sub&gt;k&lt;/sub&gt; NSPACE(n&lt;sup&gt;k&lt;/sup&gt;) by def.&lt;br&gt;
      =&amp;gt; NPSPACE ⊆ U&lt;sub&gt;k&lt;/sub&gt;DSPACE(n&lt;sup&gt;k&lt;/sup&gt;)&lt;br&gt;
      =&amp;gt; NPSPACE ⊆ PSPACE&lt;br&gt;
      It is trivial that PSPACE ⊆ NPSPACE.&lt;br&gt;
      Hence, NPSPACE = PSPACE  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. Turning Machine, Enumeration and Solvability&lt;/h2&gt;
&lt;h3&gt;Deterministic Turing Machine.&lt;/h3&gt;
&lt;p&gt;Turing machine is a model of computation that consists of a 7-tuples&lt;br&gt;
&lt;/p&gt;&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;Q&lt;/td&gt;&lt;td&gt;A finite set of states&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Γ&lt;/td&gt;&lt;td&gt;A finite set of tape alphabet&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;q0 ∈ Q&lt;/td&gt;&lt;td&gt;An initial state&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;F ⊆ Q&lt;/td&gt;&lt;td&gt;A set if final states&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;b ∈ Q&lt;/td&gt;&lt;td&gt;A blank symbol&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Σ ⊆ Γ \ b&lt;/td&gt;&lt;td&gt;A set of input symbols&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;δ: Q \ F x Γ -&amp;gt; Q x Γ  x {L, R, N}&lt;/td&gt;&lt;td&gt;A Transition function that takes a state (not final one) and a tape symbol, returns a new state, a new tape symbol and movement which is left, right or stay.&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
A TM is deterministic if and only if the action for any current state q and any symbol that can occur when the machine is in state q is unique. An action is 5-tuples: (current state, current tape symbol, new state, new state and direction of move)  
&lt;h3&gt;Universal Tuning Machine&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Motivation and concept&lt;/strong&gt; For every new problem, we need a TM to solve, but general purpose computer can execute any program that stored on hard disk. A Universal Turning Machine acts as an interpreter that takes e(M) and executes it on input s.&lt;br&gt;
&lt;strong&gt;Construct and work.&lt;/strong&gt; UTM uses fixed states, alphabet and transitions. The program M encodes the set of tuples of an arbitrary TM with arbitrary states and program. The input of the target TM is also stored on tape as s. UTM runs on e(M)&amp;amp;s, keeps track of simulated head of M and its real head, keeps track of current state of target TM.&lt;/p&gt;
&lt;h3&gt;Non-Deterministic Turing Machine.&lt;/h3&gt;
&lt;p&gt;Non-deterministic Turing Machine is a Turning Machine that has more than one possible transition for a given state and a tape symbol. This means for more than one execution path. An NDTM M is said to accept a string s if and only if there is some execution path that leads to halting with yes. Usage: It is the vital concept to the NP definition.&lt;br&gt;
Simulate NDTM with DTM: Breadth First Search or iterative deepening on NDTM&lt;/p&gt;
&lt;h3&gt;REC and RE&lt;/h3&gt;
&lt;p&gt;A language L is decided by a Turing Machine M if and only if:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s in L implies M is guaranteed to halt with yes.  &lt;/li&gt;
&lt;li&gt;s not in L implies M is guaranteed to halt with no.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If a Turning Machine is existed with such property, then L is &lt;strong&gt;Recursive Language (REC)&lt;/strong&gt;.&lt;br&gt;
A Language L is accepted by a Turing Machine M if and only if:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s in L implies M is guaranteed to halt with yes.  &lt;/li&gt;
&lt;li&gt;s not in L implies M either halt with no or it never halt.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If a Turning Machine is existed with such property, then L is &lt;strong&gt;Recursive Enumerable (RE).&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;Enumerate strings of a language&lt;/h3&gt;
&lt;p&gt;Enumerating strings of language L means explicitly produce the elements of L and put it into a list (print it). This requires only the strings that belongs to L are printed, and all strings in L are eventually printed.&lt;/p&gt;
&lt;h3&gt;Give and explain a method to enumerate the strings of a REC&lt;/h3&gt;
&lt;p&gt;The method is generate and test. Generate all string s in the REC, test each s by a TM and print out those given a ‘yes’.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;Repeat
    Generate a string w
    Check if w belongs to L by a TM. If yes, print w; if no, ignore w.
&lt;/pre&gt;


&lt;h3&gt;Give and explain a method to enumerate the strings of a RE&lt;/h3&gt;
&lt;p&gt;The idea is still generate and test but run each test on a separate thread. The number of thread is unbounded but always finite, any element of L will be printed out in finite time, because the ‘yes’ is guaranteed to halt.  &lt;/p&gt;
&lt;pre class="code literal-block"&gt;Assume TM1 accepts language L;
    A TM2 generate new string s, and start a new thread for each one that runs TM1 on string1;
    Run each thread for some number of steps. 
        If one thread halt, print yes; If not halt, just carry on.
&lt;/pre&gt;


&lt;h3&gt;Halting problem and its importance&lt;/h3&gt;
&lt;p&gt;Given a TM M and an input string x, let e(M) be the encoding of M. Does there exist an effective procedure (computable function) for deciding, for every pair (e(M), x) that does M halt for x?&lt;/p&gt;
&lt;p&gt;It is equivalent to ask whether the language L = {e(M)&amp;amp;s | M halts for s} is recursive (it is RE)?&lt;/p&gt;
&lt;p&gt;The proof of the unsolvability of many problems relies on the unsolvability of Halting problem.&lt;/p&gt;
&lt;h3&gt;Halting theorem: The Halting problem for Turing machine is unsolvable.&lt;/h3&gt;
&lt;p&gt;Assume the Halting problem is solvable, then there exists a Turing machine H that decides the Halting problem. If H can solve the Halting problem for input e(M)&amp;amp;x, H should be able to solve the Halting problem for input e(M)&amp;amp;e(M).&lt;/p&gt;
&lt;p&gt;Let H’ be a Turing machine that takes e(M) and makes a copies to obtain e(M)&amp;amp;e(M). Then the H’ execute H with the input e(M)&amp;amp;e(M), but in the case that M halts (that is H halts with yes), H’ loops forever.&lt;/p&gt;
&lt;p&gt;If the input of H’ is e(H’), then &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If H’ halts for e(H’), then H answers yes and H’ loops for ever.&lt;/li&gt;
&lt;li&gt;If H’ does not halts for e(H’), then H answers no and H’ halts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both give a contradiction. Neither H nor H’ exists, hence Halting problem is unsolvable.&lt;/p&gt;
&lt;p&gt;Note1: Halting theorem says for any fixed reasoning system, there are instances on which it fails. But NOT says, there are instances for which all reasoning systems fail.&lt;/p&gt;
&lt;p&gt;Note2: [WRONG] For any TM M and input, there does not exist a TM H decides whether M halts.
For a single pair of TM and input, there are always a TM that gives either yes or no, but we don’t know which one.&lt;/p&gt;
&lt;h3&gt;The general structure/technique of the prove: Self-reference with a twist.&lt;/h3&gt;
&lt;p&gt;In the uncountability of real number, we take the entries of diagonal and twist it by adding one to each entries. &lt;/p&gt;
&lt;p&gt;In the barber paradox, the problem is the self-reference with negation in defining the set of people shaved by the barber.&lt;/p&gt;
&lt;h3&gt;Decision Problems and Reduction&lt;/h3&gt;
&lt;p&gt;Decision problem can be states as a question of some formal system with yes/no answer.&lt;/p&gt;
&lt;p&gt;If the decision problem is solvable, then there exist a TM that for every instance of the problem, it halts with output yes or no.&lt;/p&gt;
&lt;p&gt;pi reduced to pi’ = An algorithm to solve pi’ can be directly used to solve pi. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If pi reduced to pi’ and pi’ is solvable then pi is solvable.&lt;/li&gt;
&lt;li&gt;If pi reduced to pi’ and pi is unsolvable then pi’ is unsolvable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Empty word halting problem&lt;/h3&gt;
&lt;p&gt;Give a TM M. Does M halt on epsilon? &lt;/p&gt;
&lt;p&gt;Proof: (1) show eHP reduced to HP. (2) Assume eHP is solvable. (3) HP is solvable -&amp;gt; contradiction.&lt;/p&gt;
&lt;p&gt;Assume an instance of HP, M and x; an instance of eHP, M’ and empty string e. M’ first write x onto its tape to simulate M. (eHP reduce to HP). If we can show M’ halts on e, then M halts. This is a contradiction to Halting theorem. Therefore, eHP is unsolvable.&lt;/p&gt;
&lt;h2&gt;3. NP-hardness and Reductions&lt;/h2&gt;
&lt;h3&gt;Polynomial time reduction and how reduction are used to show problems are in NP-complete&lt;/h3&gt;
&lt;p&gt;Given any instance of a problem class X.&lt;/p&gt;
&lt;p&gt;Computer an instance f(x) in problem class Y with the conversion done in polynomial time and the answer preserved, i.e., ans(x) = yes if fans(f(x)) = yes.&lt;/p&gt;
&lt;p&gt;To show NP-complete, we need to show NP-hard. If a problem is said to be NP-hard iff all problems in NP can be reduced to it in polytime.&lt;/p&gt;
&lt;h3&gt;Decision Problems&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem"&gt;SAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability"&gt;k-SAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[MONOTONE-k-SAT]&lt;/li&gt;
&lt;li&gt;[KNAPSACK]&lt;/li&gt;
&lt;li&gt;[BIN PACKING]&lt;/li&gt;
&lt;li&gt;[HAMILTONIAN CYCLE]&lt;/li&gt;
&lt;li&gt;[TSP(D)]&lt;/li&gt;
&lt;li&gt;[CIRCUIT SAT]&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Subset_sum_problem"&gt;SUBSET SUM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[NUMBER PARTITION]&lt;/li&gt;
&lt;li&gt;[GRAPH COLOURING]&lt;/li&gt;
&lt;li&gt;[INDEPENDENT SET]&lt;/li&gt;
&lt;li&gt;[CLIQUE]&lt;/li&gt;
&lt;li&gt;[VERTEX COVER]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Prove SAT is HP-hard(informal, read more on &lt;a href="http://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem"&gt;Cook-Levin Theorem&lt;/a&gt;)&lt;/h3&gt;
&lt;p&gt;If SAT is NP-hard, then every problem in NP can be reduced to SAT in polynomial time. &lt;/p&gt;
&lt;p&gt;According to the definition of NP problem, this means:&lt;br&gt;
Given an input s of size n, an arbitrary NDTM M that run in polynomial time p(n).&lt;/p&gt;
&lt;p&gt;We need to convert the NDTM and input into a SAT formula in polynomial time, such that the NDTM has an accepting computation if and only if the SAT formula has a satisfying assignment.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Using variables in the form of function of time t to describe states&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x(i, t) = 1 iff the machine in state i at time t  &lt;/li&gt;
&lt;li&gt;y(i, k, t) = 1 iff the tape element i has value k at time t  &lt;/li&gt;
&lt;li&gt;z(i, t) = 1 iff the head is at position i at time t  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If all values of these variables are given, then the execution sequence of NDTM is given.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The transition to reach state at time t + 1 only depends on state at time t and a non-determinism choice w(c, t) meaning choice c at time t.
These could be expressed using polynomial size clauses. &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The NDTM is converted into a polysize SAT formula containing variables describing the states as a function of time and allowing the need of non-determinism. The SAT formula has a satisfying formula iff there is some sequence of states of the NDTM that lead to acceptance.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(To be finished...)&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Computability</category><category>Notes</category><guid>http://www.jiaqili.me/en/posts/g53com-computability-revision-notes/</guid><pubDate>Sun, 01 Jun 2014 20:54:42 GMT</pubDate></item></channel></rss>