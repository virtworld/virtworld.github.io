<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# fb: http://ogp.me/ns/fb# " lang="en">
<head>
<meta charset="utf-8">
<base href="http://www.jiaqili.me/en/">
<meta name="description" content="Jiaqi Li's personal blog.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Virtual World</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS (en)" href="rss.xml">
<link rel="alternate" type="application/rss+xml" title="RSS (zh_cn)" href="../rss.xml">
<link rel="canonical" href="http://www.jiaqili.me/en/">
<meta property="fb:app_id" content="1523140791344197">
<!--[if lt IE 9]><script src="../assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://www.jiaqili.me/en/">

                <span id="blog-title">Virtual World</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>
                </li>
<li>
<a href="rss.xml">RSS feed</a>
                </li>
<li>
<a href="https://github.com/virtworld">GitHub</a>
                </li>
<li>
<a href="../stories/about/">About</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<li>
            </li>
<li><a href="http://www.jiaqili.me/" rel="alternate" hreflang="zh_cn">简体中文</a></li>

                
                    
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

<div class="postindex">
    <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/java-class-file/" class="u-url">Java Class 文件</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Jiaqi Li
            </span></p>
            <p class="dateline"><a href="posts/java-class-file/" rel="bookmark"><time class="published dt-published" datetime="2015-12-28T10:57:42Z" title="2015-12-28 10:57">2015-12-28 10:57</time></a></p>
                <p class="commentline">
        
<span class="fb-comments-count" data-url="/en/posts/java-class-file/">


        </span></p>
</div>
    </header><div class="e-content entry-content">
    <div>
<h3>1 Class概述</h3>
<ol>
<li>Class文件是一个以8位字节为基础单位的二进制流，多字节储存按照Big-endian的方式（既高位字节在地址低位，低位字节在地址高位）；</li>
<li>每个Class对应一个类或接口，而类或者接口不一定以文件的形式存在磁盘上；</li>
<li>Class文件储存的数据只有两种类型：无符号数和表<ol>
<li>无符号数：u1, u2, u4和 u8分别表示1个，2个，4个和8个字节;</li>
<li>表(Table)：由多个无符号数或表组成的复合数据类型。</li>
</ol>
</li>
</ol>
<h3>2 内部名称表示</h3>
<ol>
<li>
<strong>全限定名</strong>(Fully Qualified Name)是JVM中的绝对名称，比如java.lang.Object；<strong>非全限定名</strong>(Unqualified Name)是当前环境，比如类，中的相对名称，比如Object；</li>
<li>类或接口的名称都用<strong>全限定名称</strong>来表示；</li>
<li>全限定名称用CONSTANT_Utf8_info表（见下文）的结构来表示；</li>
<li>类在Class文中中的表示：比如java.lang.Object被表示为“java/lang/Object;”其中“;”为了表示名称结束；</li>
<li>方法名，字段名，局部变量名都使用<strong>非全限定名称</strong>来储存，比如inc；</li>
<li>方法名，字段名，局部变量名不能包含"."、";"、"["、"/"和Unicode，另外方法除了类初始化方法<clinit>和实例初始化方法<init>以外不能使用"&lt;"、"&gt;"；</init></clinit>
</li>
</ol>
<h3>3 描述符(Descriptor)和签名(Signature)</h3>
<ol>
<li>描述符描述字段的数据类型，方法的参数列表（数量，类型和顺序）以及返回值；</li>
<li>签名描述字段、方法和类型定义中泛型信息的字符串；</li>
<li>
<p>描述符字符含义:</p>
<p></p>
<table>
<tr>
<td>B</td>
    <td>byte</td>
    <td>C</td>
    <td>char</td>
  </tr>
<tr>
<td>D</td>
    <td>double</td>
    <td>F</td>
    <td>float</td>
  </tr>
<tr>
<td>I</td>
    <td>int</td>
    <td>J</td>
    <td>long</td>
  </tr>
<tr>
<td>S</td>
    <td>short</td>
    <td>Z</td>
    <td>boolean</td>
  </tr>
<tr>
<td>L classname   </td>
    <td>reference 一个名为&lt;Classname&gt;的实例   </td>
    <td>[   </td>
    <td>reference 一个一维数组</td>
  </tr>
</table>
</li>
<li>
<p>字段描述符，比如int的实例描述符是"I"；java.lang.Object的实例描述符是"Ljava/lang/Object;"；double的三维数组的描述符为"[[[D"；</p>
</li>
<li>方法描述符，先参数后返回值，参数按顺序在圆括号内，比如Object mymethod(char[][] c, int i, double d, Thread t)的描述符为“([[CIDLjava/lang/Thread;)Ljava/lang/Object;”</li>
<li>签名属于Java语言规范，不属于虚拟机的部分，包括泛型类型，方法描述，参数化类型描述，用于实现反射和跟踪调试（见JVS7-4.3.4）</li>
</ol>
<h3>4 Class文件结构</h3>
<table>
<tr>
<th>类型</th>
    <th>名称</th>
    <th>数量</th>
  </tr>
<tr>
<td>u4</td>
    <td>magic</td>
    <td>1</td>
  </tr>
<tr>
<td>u2</td>
    <td>minor_version</td>
    <td>1</td>
  </tr>
<tr>
<td>u2</td>
    <td>major_version</td>
    <td>1</td>
  </tr>
<tr>
<td>u2</td>
    <td>constant_pool_count</td>
    <td>1</td>
  </tr>
<tr>
<td>cp_info</td>
    <td>constant_pool</td>
    <td>constant_pool_count - 1</td>
  </tr>
<tr>
<td>u2</td>
    <td>access_flag</td>
    <td>1</td>
  </tr>
<tr>
<td>u2</td>
    <td>this_class</td>
    <td>1</td>
  </tr>
<tr>
<td>u2</td>
    <td>super_class</td>
    <td>1</td>
  </tr>
<tr>
<td>u2</td>
    <td>interfaces_count</td>
    <td>1</td>
  </tr>
<tr>
<td>u2</td>
    <td>interfaces</td>
    <td>interfaces_count</td>
  </tr>
<tr>
<td>u2</td>
    <td>fields_count</td>
    <td>1</td>
  </tr>
<tr>
<td>field_info</td>
    <td>fields</td>
    <td>fields_count</td>
  </tr>
<tr>
<td>u2</td>
    <td>methods_count</td>
    <td>1</td>
  </tr>
<tr>
<td>method_info</td>
    <td>methods</td>
    <td>methods_count</td>
  </tr>
<tr>
<td>u2</td>
    <td>attributes_count</td>
    <td>1</td>
  </tr>
<tr>
<td>attribute_info</td>
    <td>attributes</td>
    <td>attributes_count</td>
  </tr>
</table>
<ol>
<li>magic 魔数
    决定这个文件是不是Class文件，永远是0xCAFEBABE</li>
<li>minor_version &amp; major_version 次版本号和主版本号</li>
<li>constant_pool_count 常量池计数器
    从1开始，比如计数器为20，则常量池有效索引为1 - 19</li>
<li>
<p>constant_pool 常量池</p>
<ol>
<li>是一个长度为 constant_pool_count - 1的表的数组，每一项都是一个表；</li>
<li>所有的表的第一个字节为tag，表明它是何种类型的表；</li>
<li>
<p>共有14种不同的表，用来保存字面量和符号引用（类/接口的全限定名，字段/方法的名称和描述符）</p>
<p></p>
<table>
<tr>
<th>常量表</th>
    <th>项目名称</th>
    <th>类型       </th>
    <th>内容</th>
  </tr>
<tr>
<td>CONSTANT_Utf8_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>1</td>
  </tr>
<tr>
<td></td>
    <td>length</td>
    <td>u2</td>
    <td>第三项占用的字节数</td>
  </tr>
<tr>
<td></td>
    <td>bytes</td>
    <td>u1</td>
    <td>长度为length的UTF8编码的字符串</td>
  </tr>
<tr>
<td>CONSTANT_Integer_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>3</td>
  </tr>
<tr>
<td></td>
    <td>bytes</td>
    <td>u4</td>
    <td>高位在前储存的int值</td>
  </tr>
<tr>
<td>CONSTANT_Float_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>4</td>
  </tr>
<tr>
<td></td>
    <td>bytes</td>
    <td>u4</td>
    <td>高位在前储存的float值</td>
  </tr>
<tr>
<td>CONSTANT_Long_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>5</td>
  </tr>
<tr>
<td></td>
    <td>bytes</td>
    <td>u8</td>
    <td>高位在前储存的long值</td>
  </tr>
<tr>
<td>CONSTANT_Double_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>6</td>
  </tr>
<tr>
<td></td>
    <td>bytes</td>
    <td>u8</td>
    <td>高位在前储存的double值</td>
  </tr>
<tr>
<td>CONSTANT_Class_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>7</td>
  </tr>
<tr>
<td></td>
    <td>index</td>
    <td>u2</td>
    <td>对常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_Utf8_info的表，表</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>示一个类或接口的全限定名。</td>
  </tr>
<tr>
<td>CONSTANT_String_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>8</td>
  </tr>
<tr>
<td></td>
    <td>index</td>
    <td>u2</td>
    <td>对常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_Utf8_info的表。</td>
  </tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>9</td>
  </tr>
<tr>
<td></td>
    <td>class_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_Class_info的表。</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>当前字段是该类或接口的成员。</td>
  </tr>
<tr>
<td></td>
    <td>name_and_type_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_NameAndType_info</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>的表。表示当前字段的名字和描述符。</td>
  </tr>
<tr>
<td>CONSTANT_Methodref_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>10</td>
  </tr>
<tr>
<td></td>
    <td>class_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_Class_info的表。</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>该项的类型必须是类。当前字段是该类的成员。</td>
  </tr>
<tr>
<td></td>
    <td>name_and_type_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_NameAndType_info</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>的表。表示当前方法的名字和描述符。</td>
  </tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info    </td>
    <td>tag</td>
    <td>u1</td>
    <td>11</td>
  </tr>
<tr>
<td></td>
    <td>class_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_Class_info的表。</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>该项的类型必须是接口。当前字段是</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>该接口的成员。</td>
  </tr>
<tr>
<td></td>
    <td>name_and_type_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_NameAndType_info</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>的表。表示当前方法的名字和描述符。</td>
  </tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>12</td>
  </tr>
<tr>
<td></td>
    <td>index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_Utf8_info的表。</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>表示一个字段或方法的非限定名，或表示</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>特殊的方法名&lt;init&gt;</td>
  </tr>
<tr>
<td></td>
    <td>index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_Utf8_info的表。表示</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>一个字段或一个方法的描述符。</td>
  </tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>15</td>
  </tr>
<tr>
<td></td>
    <td>reference_kind</td>
    <td>u1</td>
    <td>1-9,决定方法句柄类型</td>
  </tr>
<tr>
<td></td>
    <td>reference_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引</td>
  </tr>
<tr>
<td>CONSTANT_MethodType_info</td>
    <td>tag</td>
    <td>u1</td>
    <td>16</td>
  </tr>
<tr>
<td></td>
    <td>descriptor_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_Utf8_info的表。表示</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>方法的描述符。</td>
  </tr>
<tr>
<td>CONSTANT_InvokeDynamic</td>
    <td>tag</td>
    <td>u1</td>
    <td>18</td>
  </tr>
<tr>
<td></td>
    <td>bootstrap_method_attr_   </td>
    <td>u2</td>
    <td>对当前Class文件中引导方法表的</td>
  </tr>
<tr>
<td></td>
    <td>index</td>
    <td></td>
    <td>bootstrap_methods[]数组的有效索引。</td>
  </tr>
<tr>
<td></td>
    <td>name_and_type_index</td>
    <td>u2</td>
    <td>常量池的一个有效索引，常量池在该索引的</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>位置必须是一个CONSTANT_NameAndType_info</td>
  </tr>
<tr>
<td></td>
    <td></td>
    <td></td>
    <td>的表。表示当前方法的名字和描述符。</td>
  </tr>
</table>
</li>
<li>
<p>access_flags 访问标志
    是一种掩码标志，共有16个标志位可用，当前定义了8个。</p>
<p></p>
<table>
<tr>
<td>ACC_PUBLIC</td>
    <td>0x0001</td>
    <td>是否为public</td>
  </tr>
<tr>
<td>ACC_FINAL</td>
    <td>0x0010</td>
    <td>是否为final，只能是类</td>
  </tr>
<tr>
<td>ACC_SUPER</td>
    <td>0x0020</td>
    <td>都为真</td>
  </tr>
<tr>
<td>ACC_INTERFACE</td>
    <td>0x0200</td>
    <td>表示这是一个接口</td>
  </tr>
<tr>
<td>ACC_ABSTRACT</td>
    <td>0x0400</td>
    <td>表示是否是abstract，对于抽象类和接口来说为真</td>
  </tr>
<tr>
<td>ACC_SYNTHETIC</td>
    <td>0x1000</td>
    <td>表示这个类由非用户代码产生</td>
  </tr>
<tr>
<td>ACC_ANNOTATION    </td>
    <td>0X2000  </td>
    <td>表示这是一个注解</td>
  </tr>
<tr>
<td>ACC_ENUM</td>
    <td>0x4000</td>
    <td>表示这是一个枚举</td>
  </tr>
</table>
</li>
<li>
<p>this_class 类索引
    常量池里的一个有效索引，指向一个CONSTANT_Class_info的表，通过该表，确定类的全限定名。</p>
</li>
<li>super_class 父类索引
    为0（父类为Object）或为一个指向CONSTANT_Class_info的表的有效索引。</li>
<li>interfaces_count 接口计数器
    当前类或接口的直接父类计数</li>
<li>interfaces 接口索引集合<ol>
<li>每个成员都是一个指向CONSTANT_Class_info的表的有效索引</li>
<li>按照源代码implements旁边从左到右的顺序</li>
</ol>
</li>
<li>fields_count 字段表计数器</li>
<li>fields 字段表集合<ol>
<li>用于描述接口或类中定义的变量，包括类级变量和实例级变量，但不包括方法内部的变量，也不包括继承来的。</li>
<li>有可能包括代码中没有的字段，比如内部类为了访问外部类，添加指向外部类实例的字段。</li>
<li>结构：<ol>
<li>u2 access_flags; </li>
<li>u2 name_index; </li>
<li>u2 descriptor_index; </li>
<li>u2 attributes_count; </li>
<li>attribute_info attributes[attributes_count];</li>
</ol>
</li>
<li>第一个访问标志，类似于类的访问标志，表示他是public,private,protected,static或者final之类</li>
<li>第二个是指向常量池的一个CONSTANT_Utf8_info，表示字段的非全限定名</li>
<li>第三个是指向常量池的一个CONSTANT_Utf8_info，表示字段的描述符</li>
<li>第四个是属性表计数器</li>
<li>第五个是属性表集合，用于描述0至多个字段的额外信息</li>
</ol>
</li>
<li>methods_count 方法表计数器</li>
<li>methods 方法表集合
    结构与字段表类似，属性表code中保存代码</li>
<li>attributes_count 属性表计数器</li>
<li>attributes 属性表集合<ol>
<li>通用格式如下<ol>
<li>u2 attribute_name_index; </li>
<li>u4 attribute_length; </li>
<li>u1 info[attribute_length];</li>
</ol>
</li>
<li>共有21种，没有顺序要求，比如方法体中的字节码储存在code属性内。</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/java-class-loading/" class="u-url">Java类加载机制</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Jiaqi Li
            </span></p>
            <p class="dateline"><a href="posts/java-class-loading/" rel="bookmark"><time class="published dt-published" datetime="2015-12-28T10:09:30Z" title="2015-12-28 10:09">2015-12-28 10:09</time></a></p>
                <p class="commentline">
        
<span class="fb-comments-count" data-url="/en/posts/java-class-loading/">


        </span></p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><em>本文是对《深入理解JVM》第七章的总结</em></p>
<p>虚拟机把描述类的数据从Class文件加载到内存，对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，就是虚拟机的类加载机制。</p>
<h3>1 触发类加载的条件：</h3>
<ol>
<li>碰到new， invokestatic， getstatic， putstatic四条指令时，如果类没有经过初始化，则要初始化类。通常在用new关键字实例化对象，设置静态变量（被final修饰的除外），调用静态方法时发生。</li>
<li>进行反射调用，如果类没有经过初始化，则要触发初始化。反射：可以把类、类的方法、类的字段当做对象，在运行时动态操作他们。</li>
<li>当初始化类时，其父类没有经过初始化，需要初始化其父类。</li>
<li>main所在方法的主类，在虚拟机启动时要被初始化。</li>
</ol>
<h3>2 类加载分为五个阶段（其中2-4称为连接）</h3>
<ol>
<li>加载：通过类的全限定名来获取此类的二进制字节流，将此字节流转换为方法区运行时数据结构，在内存中创建一个这个类的java.lang.Class对象（对于HotSpot而言，Class对象不在堆中，而在方法区中），作为方法区这个类的访问入口。</li>
<li>验证：确保Class文件符合虚拟机的要求，不会危害虚拟机自身安全。<ol>
<li>文件格式验证: 验证字节流是否符合Class文件规范，比如魔数，版本号，常量池tag，各种索引是否有效等，通过后字节码进入内存的方法区储存。</li>
<li>元数据验证：语义分析，来验证是否符合Java语言规范，比如继承是否合法，是否实现了所有抽象方法等。</li>
<li>方法体的字节码验证：保证方法运行时不会危害虚拟机，比如类型转换是否合法，跳转指令不会跳到方法体以外的字节码指令上。</li>
<li>符号引用验证：对类自身以外的信息进行匹配性校验，比如符号引用中的全限定名是否能找到对应的类，符号引用中的类、字段、方法的访问性是否可以被当前类访问等。这个验证发生在将符号引用转化成直接引用时。</li>
</ol>
</li>
<li>准备：将类变量分配内存，并赋初始值。这里指的是被static修饰的类的变量，而非实例变量；初始值则一般被设为该类型的默认值，比如<ol>
<li>public static int value = 123; value将会被设置为0而不是123，因为设置123是在类构造器<clinit>方法中进行的，该方法在初始化阶段才会进行；</clinit>
</li>
<li>public static final int value = 123; value将会被设置成123而不是0，因为final会在类字段的字段属性表中设置ConstantValue属性，准备阶段就会被初始化成ConstantValue属性所指定的值。</li>
</ol>
</li>
<li>解析：将常量池中的符号引用替换为直接引用。符号引用即为Class文件结构中提到的CONSTANT_Class_info、CONSTANT_Fieldref_info之类的，可以是任何字面量，只要无歧义地定位到目标即可。各个虚拟机能接受的符号引用必须一致，因为它们定义在Java虚拟机规范的Class文件格式中。直接引用可以是指针，相对偏移量或者能定位到目标的句柄。</li>
<li>初始化：执行类的构造器<clinit>():<ol>
<li>由编译器所收集的所有类变量的赋值语句和静态语句块（static{}）组成类构造器，反过来说，如果一个类或接口没有静态语句块，并且也没有对变量的赋值操作，编译器可以不产生<clinit>。</clinit>
</li>
<li>顺序是由语句在代码中的顺序决定的。静态语句块中只能使用定义在它之前的变量，之后的变量只能赋值，不能使用；</li>
<li>类构造器<clinit>不同于实例构造器<init>, 它不需要调用父类的类构造器，因为虚拟机保证在执行当前类的构造器之前，它的父类的类构造器已经执行完毕。因此父类的静态语句块执行要先于子类的变量赋值操作。</init></clinit>
</li>
<li>虚拟机保证一个类的构造器方法在多线程环境下被正确的加锁，同步，如果一个多个线程同时初始化一个类，那么只有一个线程去执行这个类的构造器，其他线程阻塞，知道活动线程执行完毕。</li>
</ol></clinit>
</li>
</ol>
<h3>3 类加载器</h3>
<ol>
<li>类加载器实现"通过类的全限定名获取描述此类的二进制字节流"的步骤。</li>
<li>类和加载它的类加载器共同确定一个类在虚拟机中的唯一性，也就是说只有在两个类时由同一个类加载器加载的前提下才能比较它们是否相等，否则即使两个类来自同一个Class文件，加载到同一个虚拟机，但是加载器不同，这两个类就一定不相等。</li>
<li>
<p>双亲委派模型(Parents Delegation Model)</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader), 虚拟机的一部分，其他类加载器都独立于虚拟机外部，并且继承自java.lang.ClassLoader。这个加载器负责<java_home>\lib目录中或者被-Xbootclasspath参数指定的路径中的被虚拟机识别的(比如rt.jar)类库加载到内存中。</java_home>
</li>
<li>扩展类加载器(Extension ClassLoader), 负责加载<java_home>\lib\ext目录下或者java.ext.dirs系统变量制定的路径中的所有类库，开发者可以直接使用此加载器。</java_home>
</li>
<li>应用程序类加载器(Application ClassLoader)，是ClassLoader的getSystemClassLoader()的返回值，也称为为系统类加载器，负责加载用户类路径ClassPath上所指定的类库，开发者可以直接使用此加载器。如果应用程序没有定义过类加载器，这是程序中默认的类加载器。</li>
<li>双亲委派模型要求除了顶层的启动类加载器以外，其他类加载器都有自己的父类加载器，这里不是继承关系，而是使用组合(Composition)关系来复用父类加载器。</li>
</ol>
<p>工作原理是：如果一个类加载器收到类加载请求，它会委派给它的父类，如此最终都被传送到顶层的启动类加载器中，只有当父类加载器无法完成这个加载的时候，子加载器才会尝试自己去加载。这能保证Java程序运行的稳定性，比如Object类在程序中都是由同一个加载器加载，所以他们都是同一个类。</p>
</li>
</ol>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/java-concurrency-2/" class="u-url">《Java并发实践》总结二：结构化并发应用程序</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Jiaqi Li
            </span></p>
            <p class="dateline"><a href="posts/java-concurrency-2/" rel="bookmark"><time class="published dt-published" datetime="2015-12-28T08:10:20Z" title="2015-12-28 08:10">2015-12-28 08:10</time></a></p>
                <p class="commentline">
        
<span class="fb-comments-count" data-url="/en/posts/java-concurrency-2/">


        </span></p>
</div>
    </header><div class="e-content entry-content">
    <div>
<h2>1 Executor框架</h2>
<p>任务是一个逻辑执行单元，而线程是使任务异步执行的机制。串行执行会降低响应性和吞吐量；每个任务都分配一个线程会造成很大开销也不利于资源管理。</p>
<p>该框架包括一个灵活的线程池，提供了不同类型的任务的执行策略，并将任务提交过程和执行过程解耦，用Runnable来表示一个任务。此外Executor框架还提供了对生命周期的支持，以及统计信息的收集、应用程序管理机制和性能监视等机制。</p>
<p>执行策略定义了任务执行的"what, where, when, how"等方面。比如在什么线程中执行任务，按什么顺序执行，多少个任务可以并发执行，队列了可以有多少个任务在等待，在任务执行之前和之后应该进行哪些操作，如果要拒绝一个任务，应该选择哪一个？等等</p>
<p>当需要灵活的执行策略时，用Executor框架来代替手动编写Thread。</p>
<h3>1.1 Executor</h3>
<p>Executor接口如下，它是java.util.concurrent异步执行框架的基础。</p>
<pre class="code literal-block">public interface Executor{
    void execute(Runnable command);
}
</pre>


<p>Executor基于生产者消费者模式，提交任务的线程相当于生产者，执行任务的线程相当于消费者</p>
<h3>1.2 ExecutorService</h3>
<p>ExecutorService接口扩展了Executor，提供了生命周期的支持和提交任务的方法。ThreadPoolExecutor实现了这个接口，但一般通过Executors的工厂方法来创建和配置线程池。</p>
<h4>1.2.1 线程池</h4>
<p>线程池与任务队列密切相关，工作线程从任务队列里获取一个任务，执行完成任务，返回线程池，等待下一个任务。</p>
<p>线程池通过重用现有的线程而不是对每个任务创建新的线程来，1. 减少线程创建和销毁时的开销; 2. 当请求到达时，工作线程通常已经存在，提高了响应性。</p>
<p>Executors的工厂方法可以配置很多种线程池，比如
1. newFixedThreadPool: 固定大小的线程池，每提交一个任务就创建一个线程，直到达到指定的最大数量；
2. newCachedThreadPool: 一个可缓存的线程池，当线程池规模超过需要处理的任务数量时，将回收空闲线程，当需要增加时，将添加新的线程，规模不存在限制;
3. newSingleThreadExecutor: 创建单线程的Executor，确保任务依照队列中的顺序执行；
4. NewScheduledThreadPool: 固定长度的线程池，通过延时或定时的方法执行任务。</p>
<h4>1.2.2 生命周期支持</h4>
<p>因为向Executor提交的任务是异步执行，有一些可能已经完成，一些在运行，一些在等待，所以关闭ExecutorService提供了一些方法来关闭Executor。</p>
<p>ExecutorService有三种状态，运行、关闭和已终止。在创建后它即处于运行状态。shutdown方法执行后，它将不再接受新的任务，同时等待已提交的（包括还在等待的）任务执行完成；shudownNow方法将尝试取消所有运行的任务，不再启动等待的任务。ExecutorService关闭后，提交的任务将由Rejected execution handler处理，它会抛弃任务，或者抛出一个RejectedExecutionException。等所有任务都完成后，ExecutorService进入已停止状态，可以调用awaitTermination来等待ExecutorService停止，或者通过isTerminated来轮训。</p>
<p>比如下面的一个web服务器：</p>
<pre class="code literal-block"><span class="k">class</span> <span class="n">LifecycleWebServer</span> {
    <span class="n">private</span> <span class="n">final</span> <span class="n">ExecutorService</span> <span class="n">exec</span> = ...;

    <span class="n">public</span> <span class="nb">void</span> <span class="n">start</span>() <span class="n">throws</span> <span class="n">IOException</span> {
        <span class="n">ServerSocket</span> <span class="n">socket</span> = <span class="nb">new</span> <span class="n">ServerSocket</span>(<span class="mi">80</span>);
        <span class="k">while</span> (!<span class="n">exec</span>.<span class="n">isShutdown</span>()) {
            <span class="k">try</span> {
                <span class="n">final</span> <span class="n">Socket</span> <span class="n">conn</span> = <span class="n">socket</span>.<span class="n">accept</span>();
                <span class="n">exec</span>.<span class="n">execute</span>(<span class="nb">new</span> <span class="n">Runnable</span>() {
                    <span class="n">public</span> <span class="nb">void</span> <span class="nb">run</span>() { <span class="n">handleRequest</span>(<span class="n">conn</span>); }
                });
             } <span class="n">catch</span> (<span class="n">RejectedExecutionException</span> <span class="nb">e</span>) {
                <span class="k">if</span> (!<span class="n">exec</span>.<span class="n">isShutdown</span>())
                    <span class="nb">log</span>(<span class="s">"task submission rejected"</span>, <span class="nb">e</span>);
             }
        }
    }

    <span class="n">public</span> <span class="nb">void</span> <span class="n">stop</span>() { <span class="n">exec</span>.<span class="n">shutdown</span>(); }

    <span class="nb">void</span> <span class="n">handleRequest</span>(<span class="n">Socket</span> <span class="n">connection</span>) {
        <span class="n">Request</span> <span class="n">req</span> = <span class="n">readRequest</span>(<span class="n">connection</span>);
        <span class="k">if</span> (<span class="n">isShutdownRequest</span>(<span class="n">req</span>))
            <span class="n">stop</span>();
        <span class="k">else</span>
            <span class="n">dispatchRequest</span>(<span class="n">req</span>);
    }
}
</pre>


<h4>1.2.3 任务提交，完成和取消</h4>
<p>Exectuor接口的execute方法只能接受Runnable，Runnable没有返回值。而扩展了的ExecutorService添加了submit方法允许提交Callable，Callable的call方法将返回一个值或者抛出异常。</p>
<p>Executor执行的任务有4个生命周期，创建，提交，开始和完成。Future表示一个任务的生命周期。将一个Runnable或者Callable通过submit方法提交给ExecutorService后返回一个Future，这个Future可以用来判断任务是否完成或者取消，以及获取任务的结果或者取消任务。</p>
<p>将Runnable或者Callable提交到ExecutorService的过程包括了一个安全地将Runnable或者Callable从提交线程发布到执行线程的过程；设置Future结果的过程也包括了，将计算结果从执行线程发布到任何通过get获得它的线程。</p>
<ol>
<li>
<p>Future的get方法：如果任务已经完成，将立即返回结果或抛出异常；如果没有完成，get将阻塞，如果设置了超时参数，那么在指定时间内仍旧没有完成将抛出TimeoutException，然后再通过Future来取消任务；如果计算过程中抛出异常，该异常被封装成ExecutionException由get重新抛出，通过getCause来获取最初的异常；如果任务被取消，将抛出CancellationException。</p>
</li>
<li>
<p>使用CompletionService：提交到ExecutorService的任务返回一个Future引用，要知道是否完成任务，需要一个个检查任务；而实现了CompletionService结合了Executor和一个BlockingQueue，把完成的Future<v>放入到一个BlockingQueue，这样就可以只要不断地从一个队列中获取完成的任务就可以了。</v></p>
<p>ExecutorCompletionService实现了CompletionSetrvice接口，它的构造函数需要一个Executor，并创建一个BlockingQueue来保存计算完的结果。当提交任务时，该任务会被包装为QueueingFuture（一个Future的子类），然后改写了该子类的done方法，当计算完后，FutureTask的done方法会被调用，结果就被放到了BlockingQueue中国。</p>
<p>摘自Stackoverflow：
ExecutorService = incoming queue + worker threads
CompletionService = incoming queue + worker threads + output queue</p>
</li>
<li>
<p>使用invokeAll：如果有一组任务，一般的做法是一个个提交，获取n个Future，然后一个个获取结果。如果使用invokeAll，它需要一组任务并返回一组Future。它按照参数中任务结合的顺序添加任务，并将返回Future全部添加到返回的集合里。当所有任务都执行完毕后，或者调用线程被中断，或者超时，invokeAll将返回，超时未完成的任务会被取消。所以invokeAll返回的任务要么是已经完成的，要么是被取消的。注意：调用invokeAll本身会导致阻塞，直到所有任务结束或超时，这和CompletionService是不同的。通过后者可以按照任务完成的顺序从BlockingQueue中获取完成的任务。</p>
</li>
</ol>
<h3>1.3 ScheduledExecutorService</h3>
<p>该接口继承了ExecutorService，用于定时或者延时的任务。ScheduledThreadPoolExecutor实现了这个接口，并继承了TreadPoolExecutor。可以通过上文的Executors的工厂方法newScheduledThreadPool来创建该对象或者直接用它的构造函数。</p>
<p>应该用它来替代Timer类，因为在定时的精准性以及异常处理上，ScheduledThreadPoolExecutor更好。</p>
<h3>1.4 Executor框架的UML图</h3>
<p>Image from http://www.uml-diagrams.org/java-7-concurrent-uml-class-diagram-example.html</p>
<p><img alt="ExecutorUML.png" src="http://www.uml-diagrams.org/examples/java-7-concurrent-executors-uml-class-diagram-example.png" title=" "></p>
<p><em>(未完待续)</em></p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/java-concurrency-1/" class="u-url">《Java并发实践》总结一：线程安全基础知识</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Jiaqi Li
            </span></p>
            <p class="dateline"><a href="posts/java-concurrency-1/" rel="bookmark"><time class="published dt-published" datetime="2015-12-28T07:50:12Z" title="2015-12-28 07:50">2015-12-28 07:50</time></a></p>
                <p class="commentline">
        
<span class="fb-comments-count" data-url="/en/posts/java-concurrency-1/">


        </span></p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><em>本文是《Java并发编程实战》的第2-3,5,13,15章的读书笔记，内容总结。书中所介绍的非阻塞的并发算法和数据结构比较粗略，仅限于特性和应用介绍，很少有具体实现，这里也做简单记录。更多的内容可以参考《多处理器编程的艺术》第一修订版以及https://www.cs.ox.ac.uk/teaching/materials15-16/cads。以后单独总结。</em></p>
<p>编写线程安全代码的核心在于对共享的可变的状态的访问操作进行管理。状态指储存在实例或静态域中的数据；共享表示变量可被多个线程同时访问；可变意味着变量值在其生命周期内可以发生变化。</p>
<p>当多个线程访问某个可变的状态变量，并且至少有一个写线程时，需要采用同步机制。Java的同步机制，主要是Synchronized关键词，volatile变量，显示锁(Explicit Lock)，以及原子变量(Atomic Variables)。否则，要么该变量不在多线程中共享，要么将其设置为不可变。</p>
<h2>1 线程安全性</h2>
<p>线程安全的程序并不一定完全由线程安全类构成，完全由线程安全类构成的程序也未必是线程安全的。线程安全性只与状态相关，只能用于封装其状态的整个代码，比如线程安全类，或者线程安全程序。</p>
<p>定义：当多个线程访问某个类时，不管运行时环境采取何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类时线程安全的。</p>
<p>线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。一个无状态的类肯定是线程安全的。</p>
<h3>1.1 竞态条件</h3>
<p>竞态条件是指某个计算结果的正确性取决于多个线程交替执行的顺序。造成不正确性的原因一般是基于失效的观察结果做出的判断。</p>
<h3>1.2 重排序</h3>
<p>在没有同步的情况下，编译器、处理器和运行时都可能对操作的执行顺序进行调整。</p>
<h3>1.3 发布与逸出</h3>
<p>发布是指对象能够在当前作用域之外的代码中使用，而逸出是指一个不该被发布的对象被发布。以下几种情况：
1. 将对象引用保存到公有变量中；
2. 发布某个对象时，该对象包含其他对象，可能会间接发布这些对象，比如一个发布一个集合；
3. 发布某个对象时，该对象非私有域引用的所有对象以及非私有方法可达的对象也会被发布；
4. this逸出：在构造函数返回前，别的对象获取了this引用。通常发生在在构造函数中启动线程，或者发布内部类，因为两者都包含this引用。this逸出会导致一个未构造完的类被发布，这种对象被称为是不正确的构造，应该避免在构造过程中导致this逸出。</p>
<h3>1.4 原子性</h3>
<p>如果一个操作具有原子性，那么对于访问同一个状态的所有操作（包括自身）来说，这个操作是以原子（即不可分割的）方式执行的。比如，对于线程A的任意一个指令来说，线程B执行原子操作x时，B要么已经执行完了x，要么完全没有执行x。同步机制可以确保操作的原子性。比如原子变量，参见java.util.concurrent.atomic。</p>
<h3>1.5 可见性</h3>
<p>一个线程修改了对象状态以后，其他线程能够看到发生的状态变化。同步机制可以确保可见性。当线程在没有同步的情况下读取变量，可能会得到失效数据。其中大部分变量的这个值至少由之前的某个线程设置，而不是随机值，即最低安全性；但是非volatile的double和long因为是64位的，可能读到高32位和低32位不一致的值。</p>
<h2>2 各种实现线程安全的方法</h2>
<h3>2.1 阻塞同步机制：内置锁（同步代码块/方法）</h3>
<p>Synchronized Block 包括一个作为锁的对象引用（静态的synchronized方法以Class对象作为锁），一个作为由这个锁保护的代码块。每个对象都包含一个可以被用作同步的锁，这些被称为内置锁或者Monitor Lock。</p>
<p>内置锁相当于一种互斥体，只能最多由一个线程持有这种锁，相当于这个锁保护的代码块以原子的形式被执行。任何其他请求这个锁的代码，都将被阻塞直到锁可用。</p>
<p>如果某个线程想获得一个由它自己持有的内置锁，那么会成功，因为内置锁是可重入的。一种可重入锁的实现方式是每个锁关联一个计数器和持有者线程，当计数器为0时，即为解锁状态，当一个线程请求一个未被持有的锁时，JVM记下该持有者，计数器置为1，当同一个线程再次请求该锁时，计数器递增，线程退出同步代码块时，计数器递减。</p>
<p>每一个共享的可变变量都应该只由一个锁来保护。对象的内置锁和其状态之间没有关联，当获取与对象关联的锁时，并不能阻止其他线程访问该对象，只能阻止其他线程获取同一个锁。对于包含多个变量的不变量，其所有变量必须由同一个锁保护。</p>
<p>访问共享状态的复合操作，比如递增，都必须具有原子性以避免竞态条件。同步可以避免竞态条件，但对于每个方法都加同步关键字，1. 会出现liveness和性能问题; 2. 同步方法的复合并不一定是原子的。</p>
<p>同步代码块大小要合理，要权衡各种设计需求，比如安全性（必须满足），简单性（不要将同步代码块拆分地过细）和并发性（对尽可能短的代码进行同步）。如果持有锁的时间过长，会带来liveness和性能问题，特别是大量计算和IO时不要持有锁。</p>
<h3>2.2 阻塞同步机制：volatile变量</h3>
<p>volatile是一种比Synchronized更轻量级的同步机制，也算是一种内置锁。</p>
<p>变量什么为volatile后，涉及该变量的操作不会与其他内存操作一起重排序。</p>
<p>volatile变量不会被缓存在寄存器或其他对其他处理器不可见的地方，读取volatile变量时总会返回最新值。</p>
<p>仅在以下情况下建议使用：确保它自身状态或者引用对象的可见性，标记一些重要的程序生命周期（比如中断某个循环的条件）。</p>
<p>volatile不能确保原子性，比如它们的变量自增操作不是原子性的，只能保证可见性；而加锁机制可以确保原子性和可见性。</p>
<h3>2.3 阻塞同步机制：显示锁</h3>
<p><em>本节也摘抄/参考了java.util.concurrent.locks文档</em></p>
<h4>2.3.1 Lock接口</h4>
<p>Synchronized内置锁提供原子性和可见性，但是无法中断一个等待获取锁的线程，也无法实现非阻塞的加锁机制，而Lock还能同时提供可定时，可轮训，可中断的锁获取操作，它的实现ReentrantLock和ReentrantReadWriteLock还提供公平性的锁获取选项。</p>
<p>所有的加锁方式是显示的，意味着没有在finally块中显示的unlock是很危险的。</p>
<p>选择何种锁？应该避免混合使用。建议仅当内置锁不能满足要求的时候，才考虑显示锁。</p>
<pre class="code literal-block">public interface Lock{
    void lock();
    void lockInterruptibly() throws InterruptedException;
    Boolean tryLock();
    Boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
</pre>


<p>显示锁的标准使用方式</p>
<pre class="code literal-block">Lock l = new SomeLock();
//…
l.lock();
try{…}
finally{
    l.unlock();
}
</pre>


<h4>2.3.2 锁的获取</h4>
<ol>
<li>轮训获取锁：通过一个循环配合tryLock()来不断尝试获取锁，tryLock()是非阻塞的锁获取操作，它立即返回是否成功获取锁的boolean。注意如果不能获取到所有的锁，应释放已获得的锁，然后重新尝试获取全部的锁；</li>
<li>可中断地获取锁：lockInterruptibly() 在等待获取锁的过程中可接受中断信号；</li>
<li>时间限制锁：使用带参数的tryLock，线程将等待指定的时间。如果获取到锁，或者被中断，或者超时，函数返回；</li>
</ol>
<h4>2.3.3 ReentrantLock</h4>
<p>重入锁的可以构造为公平的或者非公平的。默认构造函数生成的是非公平的锁。对于公平的重入锁，如果有另一个线程持有锁，或者有其他线程在队里中等待锁，新发出请求的线程将被放入队里中等待；对于非公平的重入锁，只有当某个线程持有锁时才，新线程才进入等待队列。注意，不带参数的tryLock()会无视公平性设置。</p>
<p>当然重入锁顾名思义，还允许当前线程重复获取锁。</p>
<p>非公平的锁其吞吐量一般比公平的锁更高，因为在上一个线程释放锁恢复下一个线程，到这个线程真正开始运行之间有延迟，期间非公平锁允许后来的线程抢占锁，这可能造成在线程还没完全恢复的期间，另一个线程已经完成获取锁到释放锁的全过程。</p>
<p>当锁持有时间较长或者锁被请求的间隔时间较长时，应该使用公平锁。</p>
<h4>2.3.4 ReadWriteLock接口</h4>
<pre class="code literal-block">public interface ReadWriteLock{
    Lock readLock();
    Lock writeLock();
}
</pre>


<p>读写锁的目的是允许多个读线程同时持有锁，提高读操作的并发。文档要求所有实现读写锁接口的类都保证可见性。</p>
<p>实现一个读写锁时需要考虑以下方面：
1. 当写线程释放write lock，并且还有读线程和写线程同时等待时，应该优先允许读线程还是写线程？常见的偏好是写线程，因为写操作期望来说比较短而且不常见；偏好读操作不太常见，因为如果读取线程频繁并且时间较长的话，可能导致一个写线程较长的延迟。或者也可以实现为公平的，即先到先得的策略；
2. 当一个读线程持有锁并且有写线程等待时，新的读线程能否获取到锁？如果允许读线程这时候进入，可以导致写线程无限期地推迟，如果偏好写线程将减少潜在的并发；
3. 是否可重入？一个持有write lock的线程能否再次获取write lock?是否可以同时获取一个read lock?
4. 写线程是否可降级为读线程，在不释放其write lock的前提下？读线程是否可以优先于其他等待的写线程升级为写线程?</p>
<h4>2.3.5 ReentrantReadWriteLock</h4>
<p>允许构造为公平的或者非公平的锁。</p>
<p>和重入锁一样，重入读写锁允许重入，但是非重入读线程必须等待所有write lock被当前的写线程释放才可能进入，这是它的重入限制。</p>
<p>允许写线程降级：当一个线程获取write lock后，它可以再获取read lock，然后释放write lock。但是不允许一个读线程升级。</p>
<p>对于非公平的可重入读写锁，只要符合重入限制，读线程和写线程获取锁的顺序是不确定的。</p>
<p>对于公平的可重入读写锁，获取锁的顺序大体上取决于等待的时间。当锁被释放时，等待时间最长的一组读线程，或等待时间最长的一个写线程会得到锁；对于非重入的读线程，如果当前持有锁的是写线程，或者有写线程等待，那么该线程将等待，直到当前等待时间最长的写线程获取并释放锁以后才能获取锁。不过如果当前等待的写线程放弃等待，造成该读线程成为等待队列里等待时间最长的线程，并且当前没有write lock被持有，那么该读线程被允许获取read lock；对于非重入的写线程，必须等待到没有read lock或者write lock被持有才能进入。</p>
<p>同样地，不带参数的tryLock会无视公平性。</p>
<h4>2.3.6 使用哪种显示锁</h4>
<p>读取为主的数据结构应使用读写锁，其它情况下应该使用重入锁，但是可能非阻塞的数据结构性能会更好。</p>
<h3>2.4 原子变量与非阻塞同步机制</h3>
<p>目前并发算法领域的研究方向是用底层原子机器指令，比如CAS，代替锁来实现数据一致性的非阻塞算法。非阻塞算法设计和验证上非常复杂，但是多个线程出现竞争时不会出现阻塞，能进行细粒度的协调，并且能极大减少开销。此外，通过CAS操作实现的Java原子类本身也提供了类似volatile的可见性，还支持原子操作。</p>
<h4>2.4.1 锁的劣势</h4>
<ol>
<li>挂起和回复线程存在很大的开销，特别是对于细粒度的操作；</li>
<li>即使volatile不需要上下文切换和线程调度，并且保证可见性，但是它不能保证原子的复合操作，比如自增；</li>
<li>线程等待锁时不能做其他的事情，一旦持有锁的线程永久阻塞，其他等待该锁的线程必须一致等下去。如果被阻塞的线程优先级高，持有锁的线程优先级低，则造成了优先级反转。</li>
</ol>
<h4>2.4.2 受硬件支持的Compare-and-Set(CAS)操作</h4>
<p>compareAndSet(variable, expectedValue, newValue);</p>
<p>Variable: 需要读写的内存位置
expectedValue：期望的该内存位置保存的值
newValue：希望更新的值</p>
<p>CAS通过原子的方式执行以下操作，读取variable的值，和expectedValue进行比较，一致则将variable更新为newValue，不一致则不更新，无论一致与否都返回variable原有的值。</p>
<p>CAS是实现其他非阻塞数据结构的基础构件，它不会造成更新失败的线程的阻塞，而是仅仅知道它更新失败，可以再次尝试。</p>
<p>Java.util.concurrent.aromic包中的类是基于硬件CAS操作的实现。</p>
<h4>2.4.3 Atomic类</h4>
<ol>
<li>粒度比锁细，量级更轻，可用于实现高性能的并发代码；</li>
<li>相比于使用锁的算法，使用原子类的算法更不易出现延迟，如遇竞争，更容易回复；</li>
<li>因为它利用硬件的支持，在竞争的情况下能提供更高的可伸缩性。</li>
<li>原子类可以作为一种更好的volatile变量</li>
</ol>
<p>常用的原子类比如标量类的AtomicInteger, AtomicLong, AtomicBoolean以及AtomicReference，还有支持Integer，Long和Reference的数组类。</p>
<p>AtomicInteger使用get和set方法作为访问值的接口，并提供一个compareAndSet的读改写操作，还有递增、添加、递减等操作。</p>
<h4>2.4.4 非阻塞算法（非阻塞栈作为例子）</h4>
<p>非阻塞算法：一个线程失败或挂起不会导致其他线程也失败或者挂起。
无锁算法：算法的每个步骤中都存在某个线程能够继续执行下去。</p>
<p>如果算法中仅用CAS作为协调线程之间的操作，并能正确的实现，那么它是一种非阻塞的无锁算法。</p>
<p>常见的数据结构都可以实现为非阻塞算法，包括栈、队列、散列表等。以下摘抄书中的栈的算法：</p>
<pre class="code literal-block">public class ConcurrentStack &lt;E&gt; {
    AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;Node&lt;E&gt;&gt;();
    public void push(E item) {
        Node&lt;E&gt; newHead = new Node&lt;E&gt;(item);
        Node&lt;E&gt; oldHead;
        do {
            oldHead = top.get();
            newHead.next = oldHead;
        } while (!top.compareAndSet(oldHead, newHead));
    }   

    public E pop() {
        Node&lt;E&gt; oldHead;
        Node&lt;E&gt; newHead;
        do {
            oldHead = top.get();
            if (oldHead == null)
                return null;
                newHead = oldHead.next;
        } while (!top.compareAndSet(oldHead, newHead));
        return oldHead.item;
    }

    private static class Node &lt;E&gt; {
        public final E item;
        public Node&lt;E&gt; next;
        public Node(E item) {
            this.item = item;
        }
    }
}
</pre>


<p>上述算法的top变量是一个性能瓶颈，因为对它的操作无法并发，一种处理方法是将Push和Pop操作互相抵消，以避免对栈的额外操作。[1]</p>
<p>[1] Lecture on Concurrent Stack in CADS at University of Oxford 2015, https://www.cs.ox.ac.uk/teaching/materials15-16/cads/Lectures/stacks.pdf</p>
<p><em>更多关于使用CAS等底层指令来代替锁来实现非阻塞的算法(以后会总结)参见：https://www.cs.ox.ac.uk/teaching/courses/2015-2016/cads/ 和《多处理编程的艺术》第一版修订版</em></p>
<h3>2.5 线程封闭</h3>
<p>实现线程安全的另一种方法，不共享数据，只在线程内访问数据（不算事同步机制）。当某个对象封闭在一个线程中时，即使对象不是线程安全的，对它的操作也将是线程安全的。</p>
<ol>
<li>使用volatile变量本身的可见性，再确保只有一个线程对其进行写入操作，这样就相当于将修改封闭于一个线程中，实现了线程封闭；</li>
<li>使用局部变量（栈封闭）。因为局部变量本身位于执行线程的栈中，其它线程无法访问。对于基本类型的局部变量，它们始终是线程封闭的；对于引用的对象，需要确保它们不会逸出；</li>
<li>ThreadLocal类。将某个值与保存值的对象关联起来：每个对象都保存一份该变量的副本，一个线程读写该变量相当于读写它自己的副本。可以将它看做是Map<thread t>，但是实际上各自的副本保存在线程中，线程结束时会被垃圾回收。一般用于防止对可变的singleten变量和全局变量进行共享。使用get和set方法来访问变量。初次调用get方法时，将调用initialValue来初始化值。</thread>
</li>
</ol>
<pre class="code literal-block">// 1. 变量定义
private static ThreadLocal&lt;T&gt; localVar = new ThreadLocal&lt;T&gt;{ 
    public T initialValue(){ return someT;}
};
</pre>


<pre class="code literal-block">// 2. 变量使用
public static T getT(){ 
    return localVar.get();
}
</pre>


<h3>2.6 使用（实际上）不可变对象以及安全的发布</h3>
<p>不可变对象一定是线程安全的。对于多个变量的复合操作的原子性可以通过将它们封装到一个不可变对象中来实现。注意，即使对象的所有域都是final的也可能是可变的，因为final引用的对象可以改变。</p>
<p>不可变对象：
1. 对象创建以后其状态不能修改；
2. 对象的所有域都是final类型的；
3. 对象是正确创建的，创建期间，this引用没有逸出；</p>
<p>实际上不可变对象：
1. 从技术上看是可以改变的，但是其状态在发布后不会再改变的对象。</p>
<p>安全的发布</p>
<p>对象的引用和状态必须同时对其他线程可见。比如下面就是不安全的发布：</p>
<pre class="code literal-block">public Holder holder;
public void initialise(){
    Holder = new Holder(12); 
}
</pre>


<p>一个正确构造的对象可以通过以下方式安全地发布：
1. 在静态初始化函数中初始化一个对象引用；
2. 将对象引用保存到volatile类型的域或者AtomicReference对象中；
3. 将对象的应用保存到某个正确构造对象的final类型域中；
4. 将对象的引用保存到一个由锁保护的域中。比如将对象放入到一个线程安全的容器中，容器自带内部同步机制。</p>
<p>不同可变性的对象的发布：
1. 不可变对象可以通过任意机制来发布，即使发布这些对象没有使用同步，任何线程仍可以安全地访问不可变对象并不需要额外的同步措施；
2. 任何线程都可以在没有额外同步机制的情况下，安全地使用被安全发布的实际上不可变对象；
3. 可变对象发布时需要使用同步，并且每次访问都要使用同步机制来保证原子性和可见性。</p>
<p>线程安全的使用和共享对象的策略
1. 线程封闭
2. 只读共享：指的是不可变对象和实际上不可变对象
3. 线程安全共享：对象内部实现同步机制，通过共有接口来实现访问
4. 保护对象：通过特定的锁来访问的对象。</p>
<h2>3 并发构建模块与常见模式</h2>
<h3>3.1 同步容器类</h3>
<p>早起的同步容器类，比如Vectorhe和Hashtable，都是线程安全的，他们将每个公有方法都进行同步。这种方法将严重降低并发性，并影响吞吐量。</p>
<p>在这些容器上的复合操作，比如迭代和条件运算，也不需要客户端额外加锁，但是在多个线程并发地修改容器时会出现问题。比如进行“先检查再运算”的getLast和deleteLast可以多线程同时调用，但是一个线程调用getLast一个线程调用deleteLast就可能发生数组越界异常。</p>
<p>再比如使用这些容器的客户端执行迭代操作时必须加锁（降低并发性），来保证没有ConcurrentModificatrionException。因为一旦其他线程并发的修改容器，那么在迭代期间容器的计数器发生修改，hasNext和next会抛出该异常。这种抛出异常的方式并不一定保证所有并发修改都被检测到，因为这种计数器检查并没有在同步的情况下进行，因此可能会看到失效的值，导致迭代器不会意识到已经发生了修改。</p>
<p>迭代甚至可能隐式地发生，比如容器的toString方法，hashCode，equals，containsAll，removeAll，retainAll都会隐式地对容器进行迭代，这些隐式迭代器不是线程安全的。</p>
<p>除了前面说到的加锁，另一种解决办法是克隆容器，并在副本上进行迭代，因为副本封闭在线程内，其他线程不可能同时对其修改，但是克隆会带来显著地性能开销。</p>
<h3>3.2 并发容器类</h3>
<h4>3.2.1 ConcurrentHashMap</h4>
<p>和同步容器不同，ConcurrentHashMap并没有对每一个方法加锁实现同步，而是使用一种粒度更细的锁，称为分段锁(Lock Striping)。</p>
<p>任意数量的读线程可以并发的访问ConcurrentHashMap，一定数量的写线程可以并发地修改ConcurrentHashMap。迭代器也不会抛出ConcurrentModificatrionException。</p>
<p>在并发访问环境下它能实现更高地吞吐量，而在单线程环境下只损失很小的性能。只有当应用程序需要加锁Map以进行独占访问时，才应该放弃使用ConcurrentHashMap。</p>
<h4>3.2.2 ConcurrentSkipListMap  ConcurrentSkipListSet</h4>
<p>分别作为SortedMap，和SortedSet的并发替代品。</p>
<h4>3.2.3 CopyOnWriteArrayList和CooyOnWriteArraySet</h4>
<p>分别用于List和Set的并发替代。每次修改时，都会创建并发布一个新的容器副本，这提供了更好的性能而且迭代器不会抛出ConcurrentModificatrionException。
每次修改容器都会复制底层数组，需要一定的开销，特别是当容器较大的时候。仅当迭代操作远远多于修改操作时，才应该使用CopyOnWrite容器。
Queue and BlockingQueue</p>
<p>虽然LinkedList可以模拟Queue，事实上也正是LinkedList实现Queue，但是为了去掉List的随机访问方法，增加了Queue类。几种实现包括ConcurrentLinkedQueue和PriorityQueue（非并发）。</p>
<p>BlockingQueue接口扩展了Queue接口，而且是线程安全的。增加了可阻塞的插入和获取操作。</p>
<p>[2]关于许多并发容器的实现(以后会总结)参见：https://www.cs.ox.ac.uk/teaching/courses/2015-2016/cads/ 和《多处理编程的艺术》第一版修订版</p>
<h4>3.2.4 阻塞队列和生产者消费者模式</h4>
<p>BlockingQueue提供了可阻塞的put和take方法，即当队列满（如果是有界队列）时，put将一直等待直到队列可用，take将在队列空时等待直到队列又元素可取时。也提供了定时的offer和poll方法。队列可以是有界的也可以是无界的。有界队列是一种强大的资源管理工具，可以防止产生过多的工作项。</p>
<p>阻塞队列支持生产者消费者的设计模式。这种模式将生产数据和消费数据的过程解耦，消除了生产者类和消费者类之间的代码依赖性。生产者把数据放入队列，消费者从队列里获取数据来处理。</p>
<p>一种常见的生产者消费者设计模式就是线程池和工作队列的组合，比如Executor任务执行框架。</p>
<p>通过信号量(Semaphore)可以创建其他阻塞数据结构。</p>
<p>实现包括LinkedBlockingQueue，ArrayBlockingQueue，PriorityBlockingQueue，还有SynchronousQueue。最后的一个并没有维护一个队列的储存空间，而是维护了一组线程，这些线程等待着把元素加入或移除队列。因为它没有储存功能，所以put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够的消费者时，并且总有一个消费者准备好接受工作时，才可以使用SynchronousQueue。</p>
<p>双端队列Deque和BlockingDeque分别对Queue和Blocking进行扩展。Deque可以在队列头和尾插入和移除。具体实现包括ArrayDeque和LinkedBlokcingDeque。</p>
<p>Work Stealing是与生产者消费者类似的设计模式。每个消费者有自己的双端队列，如果一个消费者完全了自己的队列，那么它可以从其他消费者的双端队列的末尾中获取工作。这样的设计，不会在一个工作队列上发生竞争，一个线程从另一个线程队列的尾部获取工作时，也降低了对头部获取队列的竞争。</p>
<p>Work Stealing适合与一个线程既是消费者又是生产者的情况。比如爬虫程序处理一个页面后，会产生更多需要处理的页面，垃圾回收阶段对堆的标记。当一个工作线程找到一个新的任务单元时，会将其放到自己队列的末尾。当自己的双端队列为空时，它会查询其他队列的末尾获取新的任务。</p>
<p>中断是一种协作机制，线程A中断线程B时，B会在执行到某个可以暂停的地方停止正在执行的操作。BlockingQueue的put和take会抛出InterruptedException，任何抛出该异常的方法是一个阻塞方法，而调用了一个可能抛出该异常的方法时，自己的方法也变成了一个阻塞方法，并且必须要处理对中断的响应：
1. 将该异常继续传递给调用者；
2. 捕获异常，并调用当前线程上的interrupt方法。</p>
<h3>3.3 同步工具类</h3>
<p>同步工具类可以是任何一个对象，它们封装了一些状态，能根据自身的状态来协调线程的控制流。像阻塞队列不仅保存工作内容还可以协调控制流，所以它也可以作为同步工具类。另外的同步工具类，包括信号量Semaphore，栅栏Barrier和闭锁Latch。</p>
<h4>3.3.1 闭锁</h4>
<p>闭锁等待某些事件全部结束，结束前等待的线程都不能通过；到达结束状态时，闭锁会允许所有线程通过，并且闭锁的状态不会再改变。</p>
<p>CountDownLatch是一种闭锁的实现。它可以使一个或多个线程等待一组事件的翻身，闭锁状态包括一个计数器，并被初始化为一个正整数，表述需要等待的事件的数量。每发生一个事件，该变量就递减。线程调用await方法等待计数器为0，为0时表示所有事件都已经发生。比如下面这个例子：</p>
<pre class="code literal-block">public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        for (int i = 0; i &lt; nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) { }
                }
            };
            t.start();
        }
        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end-start;
    }
}
</pre>


<h4>3.3.2 信号量</h4>
<p>Semaphore用来控制同时访问某个特定资源的操作数量，可以实现某种资源池，或者对容器施加边界。</p>
<p>二值信号量是一种特例，就是初始值为1的信号量，可以用做互斥体(mutex)并具备不可重入的加锁寓意。</p>
<p>当信号量被用作实现资源池时，我们可以构造固定长度的资源池</p>
<h4>3.3.3 栅栏</h4>
<p>与闭锁类似，不过闭锁用于等待事件，它用于等待其他线程，只有当所有线程到达Barrier的时候才能继续执行。当线程到达Barrier的时候调用await，线程将等待直到所有线程到达，然后Barrier会打开，所有线程释放，而Barrier会重置。await调用超时会被中断时，栅栏就被打破了，所有等待线程终止等待并抛出BrokenBarrierException。如果成功通过栅栏，每个线程会收到一个返回的唯一的到达索引号。比如模拟程序中需要用到栅栏。</p>
<p>Exchanger是除了Barrier外的另一种栅栏的形式，它是两方的栅栏，各方在栅栏位置交换数据。当两个线程通过Exchanger交换对象时，这种交换就把两个对象安全的发布给了另一方。</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/java-gc/" class="u-url">Java垃圾收集技术</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Jiaqi Li
            </span></p>
            <p class="dateline"><a href="posts/java-gc/" rel="bookmark"><time class="published dt-published" datetime="2015-11-26T16:00:00Z" title="2015-11-26 16:00">2015-11-26 16:00</time></a></p>
                <p class="commentline">
        
<span class="fb-comments-count" data-url="/en/posts/java-gc/">


        </span></p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><em>这篇是对《深入理解Java虚拟机》的第三章的总结笔记，G1部分还没有细看</em></p>
<h3>1 判断对象存活与否</h3>
<h4>1.1 引用计数器(没有GC使用)</h4>
<ul>
<li>每当有一个地方引用对象时，数值就+1，引用失效时，数值就-1。</li>
<li>问题是无法解决对象之间的循环引用问题，比如对象A的一个字段引用B，对象B的一个字段引用A，然后对象A和B被设置为null，这时无法回收A和B。</li>
</ul>
<h4>1.2 可达性分析</h4>
<ul>
<li>从一系列GC Roots开始搜索，如果GC Roots到这个对象不可达时，则该对象是不可用的。</li>
<li>GC Roots包括虚拟机栈中引用的对象，本地方法栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象。</li>
</ul>
<h3>2 finalize()</h3>
<ol>
<li>可达性分析后没有与任何GC Roots引用链相连接的对象，会被第一次标记；</li>
<li>这些对象会被筛选是否需要执行finalize()方法：当对象没有覆盖finalize或者finalize已经调用过时，该方法就不会被执行，也就是说finalize最多只会执行一次对于任何一个对象；</li>
<li>对于有必要执行finalize的对象，会被放到一个F-Queue的队列中，由一个虚拟机建立的低优先级线程去执行；</li>
<li>在finalize方法中对象可以和引用链上的任何一个对象建立关联；</li>
<li>之后GC会对F-Queue中的对象进行第二次标记，如果对象重新和引用链中的对象建立关联，则不会被回收。</li>
<li>实践中，不要使用这个方法，因为不确定性的大，运行代价高。</li>
</ol>
<h3>3 永久代垃圾收集</h3>
<ul>
<li>废弃常量：没有任何String对象引用常量池中的某个常量，则它会被清理出常量池</li>
<li>无用的类：该类所有实例都被回收，并且；加载该类的ClassLoader已被回收，并且；该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法。</li>
</ul>
<h3>4 GC算法</h3>
<h4>4.1 标记-清除算法</h4>
<ul>
<li>用来回收老年代。首先标记出所有需要回收的对象，然后统一回收所有被标记的对象。</li>
<li>问题：两个阶段效率都不高，产生大量不连续的内存片段。</li>
</ul>
<h4>4.2 复制算法</h4>
<ul>
<li>用来回收年轻代内存。将年轻代划分为一块较大的Eden区，和两块较小的Suvivor区域。每次使用Eden和一块suvivor。当回收发生时，这两块区域的存货对象被全部复制到另一块suvivor区域，然后清理掉他们的空间。</li>
</ul>
<h4>4.3 标记-整理</h4>
<ul>
<li>用来回收老年代内存。和标记-清除一开始一样，但它把所有被标记的存活对象移动到内存的一段，然后清理掉剩下的内存。</li>
</ul>
<h4>4.4 分代收集</h4>
<ul>
<li>根据年轻代和年老代的特点。年轻代每次回收都有大量对象死去，就使用复制算法；而老年代就使用标记-清理或标记-整理算法。</li>
</ul>
<p><img alt="heap.png" src="galleries/java-gc/heap.png" title=""></p>
<h3>5 内存分配和回收策略</h3>
<ul>
<li>对象一般先在eden中分配，如果启用了TLAB，则先在TLAB上分配，如果空间不够，虚拟机将发起一次Minor GC。</li>
<li>需要大量连续空间的对象，比如数组或者很长的字符串。虚拟机有一个-XX: PretenureSizeThreshold参数，大于该值的对象直接进入老年代分配。</li>
<li>对象在Eden被分配内存，经历第一次Minor GC后仍旧存货，并被幸存者空间容纳，对象年龄就设置为1，之后没经历过一次Minor GC年龄就+1，默认在年龄超过15时就进入老年代。这个值可以在-XX:MaxTenuringthreshold中设置。</li>
<li>如果在幸存者空间中相同年龄所有对象大小的综合大于幸存者空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</li>
<li>空间分配担保：</li>
<li>在进行Minor GC前，虚拟机先检查老年代可用的连续空间是否大于新生代所有对象总空间，如果大于，则此次回收是安全的（因为即使所有对象都要进入老年代，也有足够的空间）；</li>
<li>如果不是，则检查HandlePromotionFailure设置是否允许失败担保，如果允许，再检查老年代最大可用的连续空间是否大于历次进入老年代对象的平均大小，如果大于，则进行一次Minor GC，尽管可能是有风险的；如果小于，或者不允许失败担保，则进行一次Full GC。</li>
</ul>
<h3>6 垃圾收集器</h3>
<p><img alt="gc.jpg" src="galleries/java-gc/gc.jpg" title=""></p>
<h4>6.1 Serial收集器</h4>
<ul>
<li>单线程，它进行垃圾收集的时候，必须暂停其他所有工作线程，直到它结束</li>
<li>虚拟机运行Client模式下默认的新生代收集器，采用复制算法；</li>
<li>优点：简单高效，单线程收集没有线程交互的开销</li>
</ul>
<h4>6.2 ParNew 收集器</h4>
<ul>
<li>Serial的多线程版本（并行收集器：多个垃圾收集线程一起工作，但是用户线程仍旧暂停），但是单CPU环境下不会比Serial有更好的效果，随着CPU数量的增加，能增加GC时对系统资源的有效利用；；</li>
<li>虚拟机Server模式下的新生代首选收集器，仍旧采取复制算法，</li>
</ul>
<h4>6.3 Parallel Scavenge 收集器</h4>
<ul>
<li>同ParNew是一个并行收集器，采用复制算法；</li>
<li>目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间)），适合在后天运算不需要太多交互的任务。</li>
<li>两个参数用于控制吞吐量：最大垃圾收集停顿时间-XX:MaxGCPauseMills；吞吐量大小-XX:GCTimeRatio;</li>
<li>缩短最大停顿时间，是以牺牲吞吐量和缩小新生代空间来换取的，比如收集一个较小的新生代总比较大的新生代的时间要短；</li>
<li>这个收集器还有自适应调整新生代大小，eden和suvivor比例，老年代晋升年龄的机制。</li>
</ul>
<h4>6.4 Serial Old 收集器</h4>
<ul>
<li>Serial的老年代版本，单线程，标记-整理算法；</li>
<li>主要给Client模式下的虚拟机使用，在Server模式下与Parallel Scavenge配合使用，或者作为CMS的后备方案。</li>
</ul>
<h4>6.5 Parallel Old 收集器</h4>
<ul>
<li>Parallel Scavenge 的老年代版本，标记-整理算法；</li>
<li>同样是注重吞吐量和CPU资源。</li>
</ul>
<h4>6.6 CMS - Concurrent Mark Sweep</h4>
<ul>
<li>并发收集器（用户线程和垃圾收集线程交替执行，之前多线程的都是并行），目的在于缩短停顿时间，标记-清除算法；</li>
<li>初始标记(initial mark): 仅标记GC Root能直接关联到的对象，速度很快，但是单线程工作，并且用户线程暂定；</li>
<li>并发标记(concurrent mark): 进行GC Root Tracing，GC线程和用户线程同时运作；</li>
<li>重新标记(remark):修正并发标记期间，用户线程行为导致标记产生变动的那一部分对象的标记记录；多线程重现标记，但是用户线程暂定；</li>
<li>并发清除(concurrent sweep):清除，和用户线程同时运作；</li>
<li>其中并发标记和并发清除需时最长，但是可以和用户线程同时工作；因此CMS的特点是并发收集，低停顿；</li>
<li>缺点1：并发阶段需要占用CPU时间，而导致程序运行减慢，总吞吐量降低；</li>
<li>缺点2：因为采用标记-清除而不是标记-整理算法，所以会产生大量零散空间，当没有足够的连续空间来分配大对象是，必须触发Full GC；</li>
<li>缺点3：垃圾收集阶段用户线程的运行带来的问题：1. 不能等老年代全部满时再进行收集，因为要预料一部分空间提供并发收集时程序的运作，而当此预留内存无法满足程序需要时，就会发生Concurrent Mode Failure，这是将启用后备的Serial Old收集器来处理老年代，导致停顿时间很长；2. 并发清理阶段程序还在运行，就会产生新的垃圾，这部分垃圾出现在标记过程之后，需要等待下一次GC。</li>
</ul>
<h4>6.7 Garbage First (G1)</h4>
<ul>
<li>整个Java堆被划分成了多个大小相等Region，新生代和老年代不再是连续的，每个region可以属于新生代也可以属于老年代；</li>
<li>G1收集器可以建立可以预测的停顿模型，因为它有计划地避免在整个Java堆中进行全区域的垃圾收集，它跟踪各个Region里面的垃圾堆的价值大小，维护一个优先列表，每次根据允许的时间，优先回收价值最大的Region，这也是名称的由来。</li>
</ul>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/dynamic-memory-allocation/" class="u-url">Java动态内存分配</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Jiaqi Li
            </span></p>
            <p class="dateline"><a href="posts/dynamic-memory-allocation/" rel="bookmark"><time class="published dt-published" datetime="2015-11-26T15:40:00Z" title="2015-11-26 15:40">2015-11-26 15:40</time></a></p>
                <p class="commentline">
        
<span class="fb-comments-count" data-url="/en/posts/dynamic-memory-allocation/">


        </span></p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><em>这篇是对《深入理解Java虚拟机》的第二章的总结笔记</em></p>
<h3>1 运行时数据区 (Runtime Data Areas)</h3>
<h4>1.1 Java堆  (Java Heap)</h4>
<ul>
<li>虚拟机启动时创建，<strong>线程独立</strong>：所有线程共享；</li>
<li>目的是存放对象实例和数组，几乎所有对象都在堆中分配内存；</li>
<li>垃圾收集器的管理的主要区域，又叫GC堆；</li>
<li>因为GC大多采用分代收集算法，堆又可以分成<strong>新生代</strong>和<strong>老年代</strong>，新生代又可分为<strong>伊甸园</strong>，<strong>幸存者空间1</strong>，<strong>幸存者空间2</strong>；</li>
<li>堆在物理上可以是在不连续的空间，但是逻辑上是连续的；</li>
<li>主流虚拟机的堆是可扩展的（JVM标准规定可以实现成固定大小的），通过-Xmx/-Xms决定，如果堆中内存不足以分配实例，且不能扩展，就会抛出OutOfMemoryError异常。</li>
</ul>
<h4>1.2 方法区 (Method Area)</h4>
<ul>
<li>
<strong>线程独立</strong>：所有线程共享；</li>
<li>目的是存放类信息，常量，静态变量，二进制字节码的代码，HotSpot虚拟机加载类的时候创建的类对象也存放于此；</li>
<li>HotSpot用GC管理此区域，也叫做<strong>永久代</strong>，GC主要进行常量池的回收和对类型的卸载；</li>
<li>无法满足内存分配需求是抛出OutOfMemoryError异常。</li>
<li>其中有<strong>运行时常量池</strong>，Class文件中的常量池（包括字面量和符号引用）将在类被加载后进入运行时常量池；运行时常量池通常还会储存解析后的直接引用；</li>
</ul>
<h4>1.3 程序计数器(Program Counter Register)</h4>
<ul>
<li>线程隔离：每个线程独立使用；</li>
<li>用于指示当前线程所执行字节码的行号；</li>
<li>如果当前线程在执行一个Java方法，则它记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，则是未定义的。</li>
<li>Java多线程由线程切换并分配处理器时间的方式实现，因此为了恢复线程到上次执行的位置，每个线程需要有独立的程序计数器。</li>
</ul>
<h4>1.4 Java虚拟机栈（VM Stack）</h4>
<ul>
<li>线程隔离：每个线程独立使用；</li>
<li>每个方法在执行时都会创建一个栈帧，用于储存局部变量表（编译期间确定大学，运行时不变），操作数栈，动态链接，方法出口灯，一个方法的调用到结束，对应着一个栈帧在虚拟机栈的入栈到出栈的过程；</li>
<li>请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常，如果虚拟机允许动态扩展，但是无法申请到足够内存，就会抛出OutOfMemoryError异常。</li>
</ul>
<h4>1.5 本地方法栈(Native Stack Method)</h4>
<ul>
<li>同Java虚拟机栈，前者为Java方法也就是字节码服务，本地方法栈为Native方法服务；</li>
<li>异常同虚拟机栈。</li>
</ul>
<h3>2 对象的创建</h3>
<ol>
<li>虚拟机遇到new指令时，先检查这个指令的参数能否在常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有则进行<strong>类加载过程</strong>（见类加载机制）；</li>
<li>分配内存。</li>
<li>划分可用空间问题。指针碰撞(Bump the Point)方法：Java堆中内存是绝对规整的，也就是GC是带有压缩整理功能的，比如Serial, ParNew；空闲列表(Free List)：虚拟机维护一个列表记录哪些内存块是可用的，GC并不压缩整理，比如CMS这种基于mark-sweep的。</li>
<li>内存分配动作的线程安全问题。同步处理：采用CAS加上失败重试来保证原子性；使用本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，线程在各自的TLAB上分配内存，在TLAB用完需进行性的TLAB分配时才需要同步锁定。</li>
<li>将分配的内存空间初始化为零值。</li>
<li>对对象进行设置，比如对象的哈希码，GC分代年龄信息，属于哪个类的实例等，这些都放在对象头(Object Header)中。</li>
<li>执行<init>对象构造器方法。</init>
</li>
</ol>
<h3>3 对象的内存布：分为对象头，实例数据和对其填充</h3>
<h4>3.1 对象头</h4>
<ul>
<li>Mark Word：一个32位或者63位的信息，取决于虚拟机是32位还是64位。储存包括哈希码，GC分代年龄，锁状态标志，线程所持有的锁，偏向线程ID，偏向时间戳等。它被设计成一个非固定数据结构，可以根据对象不同状态复用自己的储存空间。</li>
<li>类型指针：指向类元数据的指针，用来确定对象是哪个类的实例；</li>
<li>如果是数组，则还要记录长度。</li>
</ul>
<h4>3.2 实例数据</h4>
<ul>
<li>包括从父类继承的和子类中定义的；</li>
<li>储存顺序受虚拟机分配策略参数和字段在源代码中定义的顺序影响：</li>
<li>HotSpot为longs/doubles, ints, shorts/chars, bytes/booleans, ordinary object pointers</li>
<li>在满足上述条件下，父类中定义的变量出现在子类之前；</li>
<li>如果CompactFields被设置，子类中较窄的变量也可能插入到父类变量的空隙中。</li>
</ul>
<h4>3.3 对象填充</h4>
<ul>
<li>HotSpot要求对象起始地址必须为8字节的整数倍，对象头正好是8字节的倍数（1倍或2倍），如果实例数据没有对齐，则需要填充。</li>
</ul>
<h3>4 对象访问：通过栈上的reference数据来操作堆上的具体对象，访问具体对象的方法分为：</h3>
<h4>4.1 句柄</h4>
<ul>
<li>堆中划分出一块空间用来作为句柄池。栈中的reference指向句柄地址，两个句柄指针分别指向对象实例地址（在堆中）和对象类型数据地址（在方法区中）。这种定位对象的好处是reference比较稳定，当GC时，对象很可能会被移动，这只要改变句柄中的实例地址指针就可以，reference不需要修改；不好的地方是需要进行两次定位，有额外开销。</li>
</ul>
<h4>4.2 直接指针访问</h4>
<ul>
<li>reference储存的直接就是对象在堆中的地址，对象空间再保存类型数据地址。好处是找到对象只需要进行一次指针定位。</li>
</ul>
<h3>5 虚拟机参数</h3>
<ul>
<li>-Xms 堆最小值，比如-Xms20m表示堆最小值为20MB；</li>
<li>-Xmx 堆最大值，将-Xms和-Xmx设置成相同可以避免堆自动扩展；</li>
<li>-Xss栈容量</li>
<li>-MaxPermSize最大方法区容量</li>
<li>操作系统内存限制-Xmx-MaxPermSize剩下的就被分给了栈和本地方法栈，可以通过减少最大堆和减少栈容量来换取更多线程。</li>
</ul>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/taught-master-in-computer-science-application/" class="u-url">英国计算机研究生申请</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Jiaqi Li
            </span></p>
            <p class="dateline"><a href="posts/taught-master-in-computer-science-application/" rel="bookmark"><time class="published dt-published" datetime="2014-07-23T20:43:42Z" title="2014-07-23 20:43">2014-07-23 20:43</time></a></p>
                <p class="commentline">
        
<span class="fb-comments-count" data-url="/en/posts/taught-master-in-computer-science-application/">


        </span></p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>作者：<a href="http://www.jiaqili.me/">Jiaqi Li</a>  |  授权方式：<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a></p>
<h2>0. 背景</h2>
<p>这篇文章主要针对宁诺学生，介绍的是英国计算机授课型研究生的申请，特别是牛津和帝国理工，部分内容也可能适用于其他地区、学校和专业。申请时间是1314学年，请注意时效性，一切以官网为准。</p>
<h2>1. 从大一到大三</h2>
<p><em>大三结束的同学可以跳过</em></p>
<h3>1.1 选课</h3>
<p>选课的时候可以考虑主修方向，个人兴趣和难易程度。 </p>
<p>首先，如果明确自己以后要学什么，可以将选修课程的大部分集中在那个区域里，你的PS和成绩单会非常有说服力。</p>
<ul>
<li>
<p>比如计算机图形，可以学一下Computer Graphics, Introduction to Image Processing, Computer Vision等；</p>
</li>
<li>
<p>比如机器学习，可以学一下Introduction to Modelling and Optimisation, Machine Learning, Data Mining Techniques and Applications等；</p>
</li>
<li>
<p>再比如系统网络方向，Computer Communications and Networks, Advanced Computer Communications, Parallel and Distributed Computing, Computer Security, Operating Systems, Concurrency, Connected Computing at Scale等；</p>
</li>
<li>
<p>AI方向有Knowledge Representation and Reasoning, Autonomous Robotic Systems, Designing Intelligent Agents, AI Programming Techniques；</p>
</li>
<li>
<p>还有HCI方向的Graphical User Interfaces, Human Computer Interaction, Collaboration and Communication Technologies 等。</p>
</li>
</ul>
<p>这只是一个建议，并不是严格的分类，课程本身都有交叉。另外，如果涉及到数学基础很强的方向，比如机器学习，建议选一些数学学院或者工程学院下面的数学课，宁诺计算机教的数学真是完全不行（真的有教过？）。如果没有明确方向的话，其实也没关系。本科阶段最好多涉猎一点各方面的内容，特别在前两三年，知识的广度比深度更重要。</p>
<p>除了主修方向以外，其他的课程可以按照自己的兴趣来选。第一，感兴趣的课程一般容易学，容易拿分；第二，如果一学期这么多课里一门都不喜欢，读书一定很痛苦。</p>
<p>最后的难易程度直接涉及到分数问题。每年因为课程大纲的变化，任课老师的变动，都有一些课容易拿分，有些则很难。除了问学长学姐以外，每学期开始一两周都是可以试听的，所以每门课都去听一下，感受一下，也可以直接问老师关于分数的问题，他们也是过来人，一般愿意回答。</p>
<h3>1.2 成绩</h3>
<p>虽然只有大三大四的成绩会决定你的学位等级，并且申研时最重要的是大三成绩，但是剑桥要求提供所有成绩，牛津，帝国也可能被要求大一和大二的成绩。其中和所申请专业有关系的科目的成绩比较重要，但也会看你大一的英语成绩。</p>
<p>英国授课型研究生的申请最简单的玩法是看成绩，复杂玩法包括很牛的推荐人，发表过论文，参加国际比赛比如ACM-ICPC并且拿奖，在比如微软亚洲研究院实习等等。如果复杂的玩不好，请努力提高成绩。开始申请前，大三的成绩基本上决定了你能申请到什么样的学校。</p>
<p>对于申请牛剑帝，如果没有到70，录取机会比较小，但也有成功的例子。分数在75分以上，其他部分（比如面试，PS，推荐信等后文会介绍）不出问题，基本上可以进至少一所。分数更高一点，可以弥补个别材料的瑕疵，比如PS，CV，面试等。</p>
<p>对于UCL，要求60以上。有50+录取的例子，也有70被拒的。取决于具体专业，有些比较热门；也取决于你的专业是否和你所学知识对口。</p>
<h2>2. 大三暑假</h2>
<p>如果你想去美国，暑假里或更早的时候，应该把GRE考掉（MIT不需要，有志于MIT的同学可以试一下）。</p>
<p>这篇文章假设你的申请目标是英国，没有GRE，但是根据你的情况可能需要雅思。如果你是2+2项目，基本上没有学校会问你要语言成绩，至少牛剑帝不需要，不排除个别学校比如据说爱丁堡还是要雅思，也不排除因为自身原因被con雅思。但你可以去试一下自己的英语水平，一个不错的成绩（雅思各项7+）对申请会有加分。如果你是4+0，牛剑基本上各项都要7+，帝国可以低一点，请参考官网。建议大三暑假前考出，大四会比较忙，或者到拿到offer后再考，压力会大一点。</p>
<p>暑假里成绩出来以后，给自己定位一下，选5所理想的学校，每个学校选好专业。如果你不打算美国这条路，剩下的就是英国，香港，加拿大，新加坡，澳洲这些地方的学校都可以进入你的考虑范围，但是整体数量也不多。牛剑9月份开放申请，帝国11月份开放申请，截止日期一般到3月份，之后名额就很少或者没有了。英国的其他学校申请时间都很长，有些甚至7月份还有名额。但是香港，加拿大等其他国家很多高校截止较早，如果有兴趣，请关注他们的官网。
假设你的大三成绩在75+，一般首选英国排名前三的学校，再加一两所保底，如果因为其他原因，比如就业、移民等特别想去某个地方的，也可以考虑新加坡、澳洲等高校。70-75一般冲一下前三，但很可能进UCL，这个分数申请香港各高校均没问题。60-70基本上把精力放在UCL这个档次上，同时也可以考虑布里斯托，爱丁堡，南安普顿等英国计算机比较好的学校。50-60可以考虑本校。</p>
<p>有了定位以后，可以准备一下自己的申请材料——PS和CV（下文具体讲）。我自己假期里考了个雅思，看了些学校的信息，其他的东西，比如材料准备，都是到10月份之后才开始的。所以，所以实践证明，大四开学后（来英国以后）再开始准备是可行的。甚至某同学圣诞节才开始写PS。</p>
<p>加一段比较主观的内容。不要找中介。中介唯一能做的事情就是写PS，接下来会介绍如何写。中介还能做什么，填申请表？没任何难度，都是个人信息。找老师写推荐信？自己一封邮件可以搞定。面试？学校Career的外教给你提供模拟面试训练（虽然我没有试过）。签证？2+2同学都签过，4+0同学请咨询你们的校友。总之，我觉得中介是挺浪费钱的，除了可能会给你省时间。</p>
<h2>3. PS</h2>
<p>PS是可能是所有材料里最开放的，准备时间最长的东西。最重要的是内容，其次是结构，这些做的好能给你加分，不好会减分；文采，语法，拼写，标点，排版等等都是相对次要的。一个合格的PS应该是：当老师读完以后，即便没有见过你，但是他的脑子里已经得有你这个人的生动的形象了，并且这个形象符合他们录取标准。所以PS要真实，具体，突出自己的特点。一般不会写自己的缺点，或做的不好的地方，除非你是用它来反衬出自己某些品质，比如因为勤工俭学，导致影响了成绩，但是最后还是如何如何。</p>
<h3>3.1 PS的内容</h3>
<p>有些学校对PS内容有要求，比如牛津和UCL，那就一定按照要求来。他们要你写的地方你都要照顾到，但不是列举，而是渗透到文章中，并从文章中体现出来。比如你想要表达自己善于快速思维，解决问题。就可以用具体的例子，比如参加学校某个活动，做了哪些事情。如果没有要求，一般可以cover到这些点：</p>
<ul>
<li>你为什么选择这个学校？这个专业？你的未来规划是什么？</li>
<li>你的motivation是什么？为什么你觉得你能胜任这个课程？</li>
<li>你是否有commitment来完成这个课程？</li>
<li>你的特点，个性是否符合我们的期望？</li>
<li>你希望从这个课程中得到什么？</li>
</ul>
<p>请用具体的经历来反应出上面的很多问题，不要枚举，也不要写成散文。别忘了PS是体现你这个“人”的，如果你的PS读完以后，感觉和CV一样的话，那基本就废了。另一点就是，凡是CV和Transcript上提到的东西，PS没有展开来写的就不要点到了。</p>
<p>不要讲故事，的确有很多模板是以故事开头的，而且的确写的很好，但是：“我从就喜欢计算机……”，然后扯上一段。除非你的英语能力达到了能够使人听了以后非常信服的程度，不然听上去真的像故事。</p>
<p>有些学校对PS长度有要求。要求多长就不要超过。没有要求的一般写两页以内。</p>
<p>对于有面试的申请，不要把自己吹的很高，你的PS将成为你的面试题！对于没有面试的申请，也要真实，没有Evidence的东西尽量少讲，撒谎更是可耻的，材料是记录在案的，就算毕业了，后来被发现申请材料有假，可能也会被取消学位。</p>
<p>所以写PS可能就一两天，但是准备得一两周。你一定要把自己的经历，能力，特色好好的梳理一下（大学以前的事情就不必提了）</p>
<h3>3.2 PS的结构</h3>
<p>PS一般没有固定结构，仅供参考。</p>
<p>第一段可以写为什么申请这个学校，为什么申请这个专业，我的motivation和我的职业规划。注意衔接，比如说要让人感觉你有明确的motivation，所以你有清晰的目标，为了这个目标，你们学校这个专业是我的最佳选择。</p>
<p>第二-三段可以写你本科阶段所学的知识。可以把理论和实践分开来讲，也可以按想关科目讲。但是千万别写成CV了，“我学过这个，我知道那个…”。实际上你要回答一个问题“为什么我能胜任这个课程？”答案是“你看，我有这些这些背景”，而你的表述得生动一点，比如你可以通过自己的motivation把这些串起来，或者其他什么方式。你甚至不必提你具体的课，只是让老师知道你学过这些想关知识就可以了。这里内容不在多，而在精，只讲有帮助的。</p>
<p>第三部分你可以讲自己做过的项目（如果和所申请专业相关），每个人至少做过一个项目，比如你大三你在项目组里担任什么角色，用了什么技术，遇到什么问题，你是如何解决，怎么体现了自己的能力，特点。</p>
<p>第四部分可以讲课堂外的经历（如果和所申请专业相关），实习，参加竞赛，发表论文，做项目等等只要能体现出对方想要的东西，你就可以加进来。还是不在多而在精</p>
<p>第五部分可以讲希望从课程中得到什么（表示自己的期望和你们的课程是相符合的），体现下自己的commitment，做个收尾。</p>
<p>你完全没必要按照我的建议写，甚至我希望你不要因为这个样板而受到拘束。PS是灵活的东西，几乎没有一篇PS是一样的。还是那个词要体现出你的特点（这个模板用的人多了，肯定会成为一个糟糕的模板）。
但是要注意，有些东西你的内容中表现不出来，需要从你的行文中表现。比如你的逻辑思维能力。这考验你CELE的课有没有学好。比如说一段话第一句总起，第二句解释，第三句举例等等。用好连接词，把文章条理弄清楚。总体上来说，很多一部分会是你的个人经历。所以之前的准备工作很重要，之后就是把你搜集出来的各种“相关”经历组织成文，然后加工使她变的符合要求，继而读起来流畅，最后变的生动。</p>
<h3>3.3 PS的其他</h3>
<p>虽然排版，语法等等不重要，不用强求，但也请把他们做到你能力范围内的最好。</p>
<p>排版用LaTex，谷歌之（或者至少要达到CELE交作业的要求）。</p>
<p>文采靠英语水平，不是一时半会儿能提高的，但是找几篇样本（外国人写的，被Oxbridge录取的）来参考会有很大帮助。</p>
<p>语法，拼写，标点。请自己和朋友帮忙多读几遍（下面会讲怎么校对）。</p>
<h3>3.4 PS的修改校对</h3>
<p>慢慢改，你的第一篇PS需要花最多的时间。从第一稿到完稿中间可能有十几搞，也可能只是读了一遍。但是一般你的第二篇、第三篇PS会很快。</p>
<p>学校的Career Service或者Academic Clinic Service能看内容结构语法，但是不会给你看的很仔细。他们对于语言问题上的建议，可以重视；内容和结构要自己拿主意。</p>
<p>自己的Supervisor/Tutor。他们一般都是这个领域的专家，你的PS中涉及的技术问题，有没有不当的地方他们都知道。而且作为过来人，他们也有写这个的经验。找他们改PS是首选，他们的建议不管是内容，结构还是语法（如果是Native Speaker）上都有很大参考作用。但是注意，他们没有义务给你改，请你好好和他们说。</p>
<p>最后找翻译公司。打印成双面A4一张，翻译公司会给你很仔细的看有没有语法，拼写，标点错误。他们完全不会给你内容上的建议，但是毕竟也是专业人士，语言上的建议可以参考。每次收费就50左右，相比中介几千块上万块就很便宜了。</p>
<h2>4. CV</h2>
<p>CV算是最简单的东西，暑假里也可以把CV写好。模板网上有很多，这个相对排版比较重要。可以参加宁波Academic Clinic Service的相关讲座，有帮助。除非你有paper发过，一般不要超过1页。一般可以包括以下内容，按是时间顺序从后到前。
1. 大学及之后的教育经历， 如果有相关课程，也加上。
2. 获得的荣誉
3. 做过的项目，发过的paper
4. 学术上的经历
5. 工作经历
6. 课外活动
7. 技能</p>
<h2>5. 推荐信</h2>
<p>找老师写推荐信的原则是，他越熟悉你越好，而不是他职位越高越好。有一个特例是，那个老师在你申请的学校有一定的威望，会有帮助。哪个老师对你了解，完全取决于你。但是一般都会要你最后一年的Supervisor写其中一封。除了Supervisor以外，你还可以找Personal Tutor。他是有义务给你写的，不会拒绝你。其他带过你的老师，比如大三小组项目的老师，也可以找。其他给你上过课的老师，你成绩不错，或者你提问题很多，他记得你的等等也可以找。</p>
<p>有些老师推荐信写的很快，等你注册他名字后，两个小时就交掉了。有些老师写的比较慢，可能要一个多月。建议留足足够的时间，4-5个礼拜如果不是很急。我觉得这是对老师的尊重吧。就算很急也要说明原因，给几个礼拜的时间写。没有一个礼拜内就要的。</p>
<p>如何问老师推荐信，参考这篇文章：<a href="http://www.wikihow.com/Ask-Your-Professor-for-a-Letter-of-Recommendation-Via-Email">How to Ask Your Professor for a Letter of Recommendation Via Email</a></p>
<h2>6. 申请</h2>
<p>有些学校九月份开放申请，有些则要等到十一月，请保持关注。申请的原则都是越早越好。</p>
<p>开放申请以后可以先开始填申请表，不管你有没有PS或者CV。只有剑桥那个系统是要在大概一个月里面都填好的，其他其他学校应该没有时间限制。你可以慢慢写PS，等推荐信。</p>
<p>如果开学后还没有PS（Research Proposal）和CV，不用急，慢慢开始写吧。等你有了这些文书以后，就开始准备推荐信吧。</p>
<p>有了PS或者RP，CV，推荐信，填好申请表格就可以提交了。有些学校要提交以后才能给老师提交推荐信的链接，比如UCL。有些学校允许你先提交，然后再等老师推荐信，比如OX和IC。申请表填仔细不要出错。等你按下提交以后，就Out of your hand了。可以休息一下了。</p>
<h2>7. 面试</h2>
<p>只有牛津、剑桥、帝国有面试。帝国是连续的审核，如果你提交的早，比如一开放申请没多久就交掉了，那么人少，审核的快，可能一个多礼拜就能有面试通知。牛津是等一批结束以后一起审核，它给出了明确的面试时间（即你知道申请结果的时间前一两周）。不需要面试的其他院校，等你交了表格以后就没你什么事了。</p>
<h3>7.1 牛津面试</h3>
<ul>
<li>电话面试，一般15-30分钟，迟到1-3分钟他打过来；</li>
<li>一开始会寒暄一下，主要是问你将来打算。</li>
<li>很快进入正题，所有的问题都是技术性的。</li>
<li>如前文所说，你的PS是最好的面试题，考官喜欢从里面找东西问你，确保你所写的你都掌握，并且能在几秒钟之内答上来。</li>
<li>另一个是Transcript里的课也是面试题。凡是涉及理论的课，特别是排序算法，图算法，Machine and Language，AI要准备好。</li>
<li>每个人问的都不一样，取决于你的申请方向（PS）和你所学（Transcript），看网上的经验没用。</li>
<li>准备好介绍做过的项目，和你的主要经历。</li>
<li>有的面试官喜欢问概念，有的则完全不问；有的喜欢让你举例子，比如说举一个图灵机不接受的语言；有的让你比较算法的好坏；</li>
<li>你要在5秒钟内答出来，至少你要不停的讲你的思路，不然超过5秒的停顿，对方会认为你不懂，继而给你提示。</li>
<li>很多很快得到Offer的面试都在15分钟左右结束了，超过20分钟的面试，一般是你回答的太慢，或者对方想多测试一下你的能力，再做定夺。</li>
<li>不会让你做个人介绍，也似乎没有人问到你为什么来牛津？这种常见问题。</li>
<li>好好复习你学过的所有理论专业知识。</li>
</ul>
<h3>7.2 帝国面试</h3>
<ul>
<li>当面面试，一对一，时间比较长，40-45分钟。</li>
<li>不会有技术问题, 但是会问你想学什么方向，最好之前研究下他们的官网。</li>
<li>会让你选一下你想学的课程，为什么选这些。</li>
<li>会让你介绍你做过的项目。</li>
<li>帝国面试，比较随意，不建议穿正装，比较像聊天。</li>
<li>帝国给面试的基本都录取了，牛津申请的基本都给面试了。</li>
</ul>
<h2>8. 录取率</h2>
<ul>
<li>牛津MSc in Computer Science 12-13年申请人数是285人，13-14年录取名额是75。</li>
<li>帝国MSc计算机方面所有小专业，申请人数过千，录取一百多。</li>
</ul>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/g53com-computability-1314-revision-notes/" class="u-url">G53COM Computability Revision Notes</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Jiaqi Li
            </span></p>
            <p class="dateline"><a href="posts/g53com-computability-1314-revision-notes/" rel="bookmark"><time class="published dt-published" datetime="2014-06-01T20:54:42Z" title="2014-06-01 20:54">2014-06-01 20:54</time></a></p>
                <p class="commentline">
        
<span class="fb-comments-count" data-url="/en/posts/g53com-computability-1314-revision-notes/">


        </span></p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><em>Contents based on G53COM lecture slides 1314 by <a href="http://www.cs.nott.ac.uk/~ajp/">Dr Andrew Parkes</a></em><br><em>These are <strong>NOT</strong> sample answers. Any definition, explanation or example listed below could be imprecise or incorrect. Please refer to your own notes and lecture slides.</em></p>
<h2>1. Definitions</h2>
<h3>Problem Classes</h3>
<ul>
<li>
<strong>NC</strong> is a set of problem that can be solved in polylog time using polynomial a number of processors.</li>
<li>
<strong>DTIME(f(n))</strong> is a set of problem that can be solved using some DTM in time f(n).</li>
<li>
<strong>P = U<sub>k</sub> DTIME(n<sup>k</sup>)</strong> is a set of problem that can be solved using a DTM in any polynomial time.</li>
<li>
<strong>P-hard</strong>: if a problem X is said to be P-hard iff all problems within P can be reduced to X using polylog time on a polynomial number of processors.</li>
<li>
<strong>P-complete</strong>: if a problem X is said to be P-complete iff it is in P and it is P-hard.</li>
<li>
<strong>NTIME(f(n))</strong> is a set of problem that can be solved using some NDTM in time f(n).</li>
<li>
<strong>NP = U<sub>k</sub> NTIME(n<sup>k</sup>)</strong> is a set of problem that can be solved using some NDTM in any polynomial time. A language is accepted by a NDTM is a set of strings that there exists one or more than one execution path of NDTM that gives yes.</li>
<li>
<strong>Reduction from X to Y</strong>: convert any instance of X to some instance of Y.</li>
<li>
<strong>NP-hard</strong>: if a problem X is said to be NP-hard iff any problem in NP can be reduced to X in polynomial time.</li>
<li>
<strong>NP-complete</strong>: if a problem X is sad to be NP-complete iff it’s in NP and it’s NP-hard.</li>
<li>
<strong>DSPACE(f(n))</strong> is a set of problem that can be solved using some DTM with space f(n).</li>
<li>
<strong>PSPACE = U<sub>k</sub> DSPACE(n<sup>k</sup>)</strong> is a set of problem that can be solved by a DTM using polynomial space.</li>
<li>
<strong>PSPACE-hard</strong>: if a problem X is said to be PSPACE-hard iff any problem in PSPACE can be reduced to X within polynomial time.</li>
<li>
<strong>PSPACE-complete</strong>: if a problem is PSPACE-complete if it is in PSPACE and it is PSPACE-hard.</li>
<li>
<strong>NSPACE(f(n))</strong> is a set of problem that can be solved using some NTDM with space f(n).</li>
<li>
<strong>NPSPACE = U<sub>k</sub> NSPACE(n<sup>k</sup>)</strong> is a set of problem that can be solved using a NTDM with polynomial space.</li>
</ul>
<h3>Relationship</h3>
<p><strong>NC ⊆ P ⊆ NP ⊆ PSPACE = NPSPACE</strong></p>
<ul>
<li>
<strong>P ⊆ PSPACE</strong>, because a poly time TM cannot use more than polyspace (space can be reuse, but time cannot). </li>
<li>
<strong>NP ⊆ PSPACE</strong>, a NDTM can be seen as an execution tree with polynomial height, any one execution path has a length of at most polynomial time. We can solve NP problem in PSAPCE by using DFS to explore the tree of possible executions due to non-determinism. Hence NP in PSPACE. </li>
<li>
<strong>Savitch’s theorem</strong>: NSPACE(f(n)) ⊆ DSPACE(f(n)<sup>2</sup>)  </li>
<li>
<strong>Prove PSPACE = NPSPACE</strong><br>
      NSPACE(f(n)) ⊆ DSPACE(f(n)<sup>2</sup>) by Savitch<br>
      NPSPACE = U<sub>k</sub> NSPACE(n<sup>k</sup>) by def.<br>
      =&gt; NPSPACE ⊆ U<sub>k</sub>DSPACE(n<sup>k</sup>)<br>
      =&gt; NPSPACE ⊆ PSPACE<br>
      It is trivial that PSPACE ⊆ NPSPACE.<br>
      Hence, NPSPACE = PSPACE  </li>
</ul>
<h2>2. Turning Machine, Enumeration and Solvability</h2>
<h3>Deterministic Turing Machine.</h3>
<p>Turing machine is a model of computation that consists of a 7-tuples<br></p>
<table>
<tr>
<td>Q</td>
<td>A finite set of states</td>
</tr>
<tr>
<td>Γ</td>
<td>A finite set of tape alphabet</td>
</tr>
<tr>
<td>q0 ∈ Q</td>
<td>An initial state</td>
</tr>
<tr>
<td>F ⊆ Q</td>
<td>A set if final states</td>
</tr>
<tr>
<td>b ∈ Q</td>
<td>A blank symbol</td>
</tr>
<tr>
<td>Σ ⊆ Γ \ b</td>
<td>A set of input symbols</td>
</tr>
<tr>
<td>δ: Q \ F x Γ -&gt; Q x Γ  x {L, R, N}</td>
<td>A Transition function that takes a state (not final one) and a tape symbol, returns a new state, a new tape symbol and movement which is left, right or stay.</td>
</tr>
</table>
A TM is deterministic if and only if the action for any current state q and any symbol that can occur when the machine is in state q is unique. An action is 5-tuples: (current state, current tape symbol, new state, new state and direction of move)  
<h3>Universal Tuning Machine</h3>
<p><strong>Motivation and concept</strong> For every new problem, we need a TM to solve, but general purpose computer can execute any program that stored on hard disk. A Universal Turning Machine acts as an interpreter that takes e(M) and executes it on input s.<br><strong>Construct and work.</strong> UTM uses fixed states, alphabet and transitions. The program M encodes the set of tuples of an arbitrary TM with arbitrary states and program. The input of the target TM is also stored on tape as s. UTM runs on e(M)&amp;s, keeps track of simulated head of M and its real head, keeps track of current state of target TM.</p>
<h3>Non-Deterministic Turing Machine.</h3>
<p>Non-deterministic Turing Machine is a Turning Machine that has more than one possible transition for a given state and a tape symbol. This means for more than one execution path. An NDTM M is said to accept a string s if and only if there is some execution path that leads to halting with yes. Usage: It is the vital concept to the NP definition.<br>
Simulate NDTM with DTM: Breadth First Search or iterative deepening on NDTM</p>
<h3>REC and RE</h3>
<p>A language L is decided by a Turing Machine M if and only if:  </p>
<ul>
<li>s in L implies M is guaranteed to halt with yes.  </li>
<li>s not in L implies M is guaranteed to halt with no.</li>
</ul>
<p>If a Turning Machine is existed with such property, then L is <strong>Recursive Language (REC)</strong>.<br>
A Language L is accepted by a Turing Machine M if and only if:  </p>
<ul>
<li>s in L implies M is guaranteed to halt with yes.  </li>
<li>s not in L implies M either halt with no or it never halt.  </li>
</ul>
<p>If a Turning Machine is existed with such property, then L is <strong>Recursive Enumerable (RE).</strong>  </p>
<h3>Enumerate strings of a language</h3>
<p>Enumerating strings of language L means explicitly produce the elements of L and put it into a list (print it). This requires only the strings that belongs to L are printed, and all strings in L are eventually printed.</p>
<h3>Give and explain a method to enumerate the strings of a REC</h3>
<p>The method is generate and test. Generate all string s in the REC, test each s by a TM and print out those given a ‘yes’.</p>
<pre class="code literal-block">Repeat
    Generate a string w
    Check if w belongs to L by a TM. If yes, print w; if no, ignore w.
</pre>


<h3>Give and explain a method to enumerate the strings of a RE</h3>
<p>The idea is still generate and test but run each test on a separate thread. The number of thread is unbounded but always finite, any element of L will be printed out in finite time, because the ‘yes’ is guaranteed to halt.  </p>
<pre class="code literal-block">Assume TM1 accepts language L;
    A TM2 generate new string s, and start a new thread for each one that runs TM1 on string1;
    Run each thread for some number of steps. 
        If one thread halt, print yes; If not halt, just carry on.
</pre>


<h3>Halting problem and its importance</h3>
<p>Given a TM M and an input string x, let e(M) be the encoding of M. Does there exist an effective procedure (computable function) for deciding, for every pair (e(M), x) that does M halt for x?</p>
<p>It is equivalent to ask whether the language L = {e(M)&amp;s | M halts for s} is recursive (it is RE)?</p>
<p>The proof of the unsolvability of many problems relies on the unsolvability of Halting problem.</p>
<h3>Halting theorem: The Halting problem for Turing machine is unsolvable.</h3>
<p>Assume the Halting problem is solvable, then there exists a Turing machine H that decides the Halting problem. If H can solve the Halting problem for input e(M)&amp;x, H should be able to solve the Halting problem for input e(M)&amp;e(M).</p>
<p>Let H’ be a Turing machine that takes e(M) and makes a copies to obtain e(M)&amp;e(M). Then the H’ execute H with the input e(M)&amp;e(M), but in the case that M halts (that is H halts with yes), H’ loops forever.</p>
<p>If the input of H’ is e(H’), then </p>
<ul>
<li>If H’ halts for e(H’), then H answers yes and H’ loops for ever.</li>
<li>If H’ does not halts for e(H’), then H answers no and H’ halts.</li>
</ul>
<p>Both give a contradiction. Neither H nor H’ exists, hence Halting problem is unsolvable.</p>
<p>Note1: Halting theorem says for any fixed reasoning system, there are instances on which it fails. But NOT says, there are instances for which all reasoning systems fail.</p>
<p>Note2: [WRONG] For any TM M and input, there does not exist a TM H decides whether M halts.
For a single pair of TM and input, there are always a TM that gives either yes or no, but we don’t know which one.</p>
<h3>The general structure/technique of the prove: Self-reference with a twist.</h3>
<p>In the uncountability of real number, we take the entries of diagonal and twist it by adding one to each entries. </p>
<p>In the barber paradox, the problem is the self-reference with negation in defining the set of people shaved by the barber.</p>
<h3>Decision Problems and Reduction</h3>
<p>Decision problem can be states as a question of some formal system with yes/no answer.</p>
<p>If the decision problem is solvable, then there exist a TM that for every instance of the problem, it halts with output yes or no.</p>
<p>pi reduced to pi’ = An algorithm to solve pi’ can be directly used to solve pi. </p>
<ul>
<li>If pi reduced to pi’ and pi’ is solvable then pi is solvable.</li>
<li>If pi reduced to pi’ and pi is unsolvable then pi’ is unsolvable.</li>
</ul>
<h3>Empty word halting problem</h3>
<p>Give a TM M. Does M halt on epsilon? </p>
<p>Proof: (1) show eHP reduced to HP. (2) Assume eHP is solvable. (3) HP is solvable -&gt; contradiction.</p>
<p>Assume an instance of HP, M and x; an instance of eHP, M’ and empty string e. M’ first write x onto its tape to simulate M. (eHP reduce to HP). If we can show M’ halts on e, then M halts. This is a contradiction to Halting theorem. Therefore, eHP is unsolvable.</p>
<h2>3. NP-hardness and Reductions</h2>
<h3>Polynomial time reduction and how reduction are used to show problems are in NP-complete</h3>
<p>Given any instance of a problem class X.</p>
<p>Computer an instance f(x) in problem class Y with the conversion done in polynomial time and the answer preserved, i.e., ans(x) = yes if fans(f(x)) = yes.</p>
<p>To show NP-complete, we need to show NP-hard. If a problem is said to be NP-hard iff all problems in NP can be reduced to it in polytime.</p>
<h3>Decision Problems</h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a></li>
<li><a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability">k-SAT</a></li>
<li>[MONOTONE-k-SAT]</li>
<li>[KNAPSACK]</li>
<li>[BIN PACKING]</li>
<li>[HAMILTONIAN CYCLE]</li>
<li>[TSP(D)]</li>
<li>[CIRCUIT SAT]</li>
<li><a href="http://en.wikipedia.org/wiki/Subset_sum_problem">SUBSET SUM</a></li>
<li>[NUMBER PARTITION]</li>
<li>[GRAPH COLOURING]</li>
<li>[INDEPENDENT SET]</li>
<li>[CLIQUE]</li>
<li>[VERTEX COVER]</li>
</ul>
<h3>Prove SAT is HP-hard(informal, read more on <a href="http://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem">Cook-Levin Theorem</a>)</h3>
<p>If SAT is NP-hard, then every problem in NP can be reduced to SAT in polynomial time. </p>
<p>According to the definition of NP problem, this means:<br>
Given an input s of size n, an arbitrary NDTM M that run in polynomial time p(n).</p>
<p>We need to convert the NDTM and input into a SAT formula in polynomial time, such that the NDTM has an accepting computation if and only if the SAT formula has a satisfying assignment.</p>
<ol>
<li>
<p>Using variables in the form of function of time t to describe states</p>
<ul>
<li>x(i, t) = 1 iff the machine in state i at time t  </li>
<li>y(i, k, t) = 1 iff the tape element i has value k at time t  </li>
<li>z(i, t) = 1 iff the head is at position i at time t  </li>
</ul>
<p>If all values of these variables are given, then the execution sequence of NDTM is given.</p>
</li>
<li>
<p>The transition to reach state at time t + 1 only depends on state at time t and a non-determinism choice w(c, t) meaning choice c at time t.
These could be expressed using polynomial size clauses. </p>
</li>
</ol>
<p>The NDTM is converted into a polysize SAT formula containing variables describing the states as a function of time and allowing the need of non-determinism. The SAT formula has a satisfying formula iff there is some sequence of states of the NDTM that lead to acceptance.</p>
<p><em>(To be finished...)</em></p>
</div>
    </div>
    </article>
</div>



        
<div id="fb-root"></div>
<script>
    // thank lxml for this
    $('.fb-comments-count').each(function(i, obj) {
        var url = obj.attributes['data-url'].value;
        // change here if you dislike the default way of displaying
        // this
        obj.innerHTML = '<fb:comments-count href="' + url + '"></fb:comments-count> comments';
    });

  window.fbAsyncInit = function() {
    // init the FB JS SDK
    FB.init({
      appId      : '1523140791344197',
      status     : true,
      xfbml      : true
    });

  };

  // Load the SDK asynchronously
  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "//connect.facebook.net/en_US/all.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2015         <a href="mailto:jiaqi.li@outlook.com">Jiaqi Li</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


            <script src="../assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
