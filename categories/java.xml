<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Virtual World (Java)</title><link>http://www.jiaqili.me/</link><description></description><atom:link href="http://www.jiaqili.me/categories/java.xml" type="application/rss+xml" rel="self"></atom:link><language>zh_cn</language><lastBuildDate>Thu, 26 Nov 2015 17:13:07 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Java垃圾收集技术</title><link>http://www.jiaqili.me/posts/java-gc/</link><dc:creator>Jiaqi Li</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;这篇是对《深入理解Java虚拟机》的第三章的总结笔记，G1部分还没有细看&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1 判断对象存活与否&lt;/h3&gt;
&lt;h4&gt;1.1 引用计数器(没有GC使用)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;每当有一个地方引用对象时，数值就+1，引用失效时，数值就-1。&lt;/li&gt;
&lt;li&gt;问题是无法解决对象之间的循环引用问题，比如对象A的一个字段引用B，对象B的一个字段引用A，然后对象A和B被设置为null，这时无法回收A和B。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.2 可达性分析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从一系列GC Roots开始搜索，如果GC Roots到这个对象不可达时，则该对象是不可用的。&lt;/li&gt;
&lt;li&gt;GC Roots包括虚拟机栈中引用的对象，本地方法栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2 finalize()&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可达性分析后没有与任何GC Roots引用链相连接的对象，会被第一次标记；&lt;/li&gt;
&lt;li&gt;这些对象会被筛选是否需要执行finalize()方法：当对象没有覆盖finalize或者finalize已经调用过时，该方法就不会被执行，也就是说finalize最多只会执行一次对于任何一个对象；&lt;/li&gt;
&lt;li&gt;对于有必要执行finalize的对象，会被放到一个F-Queue的队列中，由一个虚拟机建立的低优先级线程去执行；&lt;/li&gt;
&lt;li&gt;在finalize方法中对象可以和引用链上的任何一个对象建立关联；&lt;/li&gt;
&lt;li&gt;之后GC会对F-Queue中的对象进行第二次标记，如果对象重新和引用链中的对象建立关联，则不会被回收。&lt;/li&gt;
&lt;li&gt;实践中，不要使用这个方法，因为不确定性的大，运行代价高。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3 永久代垃圾收集&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;废弃常量：没有任何String对象引用常量池中的某个常量，则它会被清理出常量池&lt;/li&gt;
&lt;li&gt;无用的类：该类所有实例都被回收，并且；加载该类的ClassLoader已被回收，并且；该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4 GC算法&lt;/h3&gt;
&lt;h4&gt;4.1 标记-清除算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来回收老年代。首先标记出所有需要回收的对象，然后统一回收所有被标记的对象。&lt;/li&gt;
&lt;li&gt;问题：两个阶段效率都不高，产生大量不连续的内存片段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.2 复制算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来回收年轻代内存。将年轻代划分为一块较大的Eden区，和两块较小的Suvivor区域。每次使用Eden和一块suvivor。当回收发生时，这两块区域的存货对象被全部复制到另一块suvivor区域，然后清理掉他们的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.3 标记-整理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来回收老年代内存。和标记-清除一开始一样，但它把所有被标记的存活对象移动到内存的一段，然后清理掉剩下的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.4 分代收集&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据年轻代和年老代的特点。年轻代每次回收都有大量对象死去，就使用复制算法；而老年代就使用标记-清理或标记-整理算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="heap.png" src="http://www.jiaqili.me/galleries/java-gc/heap.png" title=""&gt;&lt;/p&gt;
&lt;h3&gt;5 内存分配和回收策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对象一般先在eden中分配，如果启用了TLAB，则先在TLAB上分配，如果空间不够，虚拟机将发起一次Minor GC。&lt;/li&gt;
&lt;li&gt;需要大量连续空间的对象，比如数组或者很长的字符串。虚拟机有一个-XX: PretenureSizeThreshold参数，大于该值的对象直接进入老年代分配。&lt;/li&gt;
&lt;li&gt;对象在Eden被分配内存，经历第一次Minor GC后仍旧存货，并被幸存者空间容纳，对象年龄就设置为1，之后没经历过一次Minor GC年龄就+1，默认在年龄超过15时就进入老年代。这个值可以在-XX:MaxTenuringthreshold中设置。&lt;/li&gt;
&lt;li&gt;如果在幸存者空间中相同年龄所有对象大小的综合大于幸存者空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/li&gt;
&lt;li&gt;空间分配担保：&lt;/li&gt;
&lt;li&gt;在进行Minor GC前，虚拟机先检查老年代可用的连续空间是否大于新生代所有对象总空间，如果大于，则此次回收是安全的（因为即使所有对象都要进入老年代，也有足够的空间）；&lt;/li&gt;
&lt;li&gt;如果不是，则检查HandlePromotionFailure设置是否允许失败担保，如果允许，再检查老年代最大可用的连续空间是否大于历次进入老年代对象的平均大小，如果大于，则进行一次Minor GC，尽管可能是有风险的；如果小于，或者不允许失败担保，则进行一次Full GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6 垃圾收集器&lt;/h3&gt;
&lt;p&gt;&lt;img alt="gc.jpg" src="http://www.jiaqili.me/galleries/java-gc/gc.jpg" title=""&gt;&lt;/p&gt;
&lt;h4&gt;6.1 Serial收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单线程，它进行垃圾收集的时候，必须暂停其他所有工作线程，直到它结束&lt;/li&gt;
&lt;li&gt;虚拟机运行Client模式下默认的新生代收集器，采用复制算法；&lt;/li&gt;
&lt;li&gt;优点：简单高效，单线程收集没有线程交互的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.2 ParNew 收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Serial的多线程版本（并行收集器：多个垃圾收集线程一起工作，但是用户线程仍旧暂停），但是单CPU环境下不会比Serial有更好的效果，随着CPU数量的增加，能增加GC时对系统资源的有效利用；；&lt;/li&gt;
&lt;li&gt;虚拟机Server模式下的新生代首选收集器，仍旧采取复制算法，&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.3 Parallel Scavenge 收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同ParNew是一个并行收集器，采用复制算法；&lt;/li&gt;
&lt;li&gt;目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间)），适合在后天运算不需要太多交互的任务。&lt;/li&gt;
&lt;li&gt;两个参数用于控制吞吐量：最大垃圾收集停顿时间-XX:MaxGCPauseMills；吞吐量大小-XX:GCTimeRatio;&lt;/li&gt;
&lt;li&gt;缩短最大停顿时间，是以牺牲吞吐量和缩小新生代空间来换取的，比如收集一个较小的新生代总比较大的新生代的时间要短；&lt;/li&gt;
&lt;li&gt;这个收集器还有自适应调整新生代大小，eden和suvivor比例，老年代晋升年龄的机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.4 Serial Old 收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Serial的老年代版本，单线程，标记-整理算法；&lt;/li&gt;
&lt;li&gt;主要给Client模式下的虚拟机使用，在Server模式下与Parallel Scavenge配合使用，或者作为CMS的后备方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.5 Parallel Old 收集器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Scavenge 的老年代版本，标记-整理算法；&lt;/li&gt;
&lt;li&gt;同样是注重吞吐量和CPU资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.6 CMS - Concurrent Mark Sweep&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;并发收集器（用户线程和垃圾收集线程交替执行，之前多线程的都是并行），目的在于缩短停顿时间，标记-清除算法；&lt;/li&gt;
&lt;li&gt;初始标记(initial mark): 仅标记GC Root能直接关联到的对象，速度很快，但是单线程工作，并且用户线程暂定；&lt;/li&gt;
&lt;li&gt;并发标记(concurrent mark): 进行GC Root Tracing，GC线程和用户线程同时运作；&lt;/li&gt;
&lt;li&gt;重新标记(remark):修正并发标记期间，用户线程行为导致标记产生变动的那一部分对象的标记记录；多线程重现标记，但是用户线程暂定；&lt;/li&gt;
&lt;li&gt;并发清除(concurrent sweep):清除，和用户线程同时运作；&lt;/li&gt;
&lt;li&gt;其中并发标记和并发清除需时最长，但是可以和用户线程同时工作；因此CMS的特点是并发收集，低停顿；&lt;/li&gt;
&lt;li&gt;缺点1：并发阶段需要占用CPU时间，而导致程序运行减慢，总吞吐量降低；&lt;/li&gt;
&lt;li&gt;缺点2：因为采用标记-清除而不是标记-整理算法，所以会产生大量零散空间，当没有足够的连续空间来分配大对象是，必须触发Full GC；&lt;/li&gt;
&lt;li&gt;缺点3：垃圾收集阶段用户线程的运行带来的问题：1. 不能等老年代全部满时再进行收集，因为要预料一部分空间提供并发收集时程序的运作，而当此预留内存无法满足程序需要时，就会发生Concurrent Mode Failure，这是将启用后备的Serial Old收集器来处理老年代，导致停顿时间很长；2. 并发清理阶段程序还在运行，就会产生新的垃圾，这部分垃圾出现在标记过程之后，需要等待下一次GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6.7 Garbage First (G1)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;整个Java堆被划分成了多个大小相等Region，新生代和老年代不再是连续的，每个region可以属于新生代也可以属于老年代；&lt;/li&gt;
&lt;li&gt;G1收集器可以建立可以预测的停顿模型，因为它有计划地避免在整个Java堆中进行全区域的垃圾收集，它跟踪各个Region里面的垃圾堆的价值大小，维护一个优先列表，每次根据允许的时间，优先回收价值最大的Region，这也是名称的由来。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>Java</category><category>JVM</category><guid>http://www.jiaqili.me/posts/java-gc/</guid><pubDate>Thu, 26 Nov 2015 16:00:00 GMT</pubDate></item><item><title>Java动态内存分配</title><link>http://www.jiaqili.me/posts/dynamic-memory-allocation/</link><dc:creator>Jiaqi Li</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;这篇是对《深入理解Java虚拟机》的第二章的总结笔记&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1 运行时数据区 (Runtime Data Areas)&lt;/h3&gt;
&lt;h4&gt;1.1 Java堆  (Java Heap)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机启动时创建，&lt;strong&gt;线程独立&lt;/strong&gt;：所有线程共享；&lt;/li&gt;
&lt;li&gt;目的是存放对象实例和数组，几乎所有对象都在堆中分配内存；&lt;/li&gt;
&lt;li&gt;垃圾收集器的管理的主要区域，又叫GC堆；&lt;/li&gt;
&lt;li&gt;因为GC大多采用分代收集算法，堆又可以分成&lt;strong&gt;新生代&lt;/strong&gt;和&lt;strong&gt;老年代&lt;/strong&gt;，新生代又可分为&lt;strong&gt;伊甸园&lt;/strong&gt;，&lt;strong&gt;幸存者空间1&lt;/strong&gt;，&lt;strong&gt;幸存者空间2&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;堆在物理上可以是在不连续的空间，但是逻辑上是连续的；&lt;/li&gt;
&lt;li&gt;主流虚拟机的堆是可扩展的（JVM标准规定可以实现成固定大小的），通过-Xmx/-Xms决定，如果堆中内存不足以分配实例，且不能扩展，就会抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.2 方法区 (Method Area)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程独立&lt;/strong&gt;：所有线程共享；&lt;/li&gt;
&lt;li&gt;目的是存放类信息，常量，静态变量，二进制字节码的代码，HotSpot虚拟机加载类的时候创建的类对象也存放于此；&lt;/li&gt;
&lt;li&gt;HotSpot用GC管理此区域，也叫做&lt;strong&gt;永久代&lt;/strong&gt;，GC主要进行常量池的回收和对类型的卸载；&lt;/li&gt;
&lt;li&gt;无法满足内存分配需求是抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;li&gt;其中有&lt;strong&gt;运行时常量池&lt;/strong&gt;，Class文件中的常量池（包括字面量和符号引用）将在类被加载后进入运行时常量池；运行时常量池通常还会储存解析后的直接引用；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3 程序计数器(Program Counter Register)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;线程隔离：每个线程独立使用；&lt;/li&gt;
&lt;li&gt;用于指示当前线程所执行字节码的行号；&lt;/li&gt;
&lt;li&gt;如果当前线程在执行一个Java方法，则它记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，则是未定义的。&lt;/li&gt;
&lt;li&gt;Java多线程由线程切换并分配处理器时间的方式实现，因此为了恢复线程到上次执行的位置，每个线程需要有独立的程序计数器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.4 Java虚拟机栈（VM Stack）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;线程隔离：每个线程独立使用；&lt;/li&gt;
&lt;li&gt;每个方法在执行时都会创建一个栈帧，用于储存局部变量表（编译期间确定大学，运行时不变），操作数栈，动态链接，方法出口灯，一个方法的调用到结束，对应着一个栈帧在虚拟机栈的入栈到出栈的过程；&lt;/li&gt;
&lt;li&gt;请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常，如果虚拟机允许动态扩展，但是无法申请到足够内存，就会抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.5 本地方法栈(Native Stack Method)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同Java虚拟机栈，前者为Java方法也就是字节码服务，本地方法栈为Native方法服务；&lt;/li&gt;
&lt;li&gt;异常同虚拟机栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2 对象的创建&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机遇到new指令时，先检查这个指令的参数能否在常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有则进行&lt;strong&gt;类加载过程&lt;/strong&gt;（见类加载机制）；&lt;/li&gt;
&lt;li&gt;分配内存。&lt;/li&gt;
&lt;li&gt;划分可用空间问题。指针碰撞(Bump the Point)方法：Java堆中内存是绝对规整的，也就是GC是带有压缩整理功能的，比如Serial, ParNew；空闲列表(Free List)：虚拟机维护一个列表记录哪些内存块是可用的，GC并不压缩整理，比如CMS这种基于mark-sweep的。&lt;/li&gt;
&lt;li&gt;内存分配动作的线程安全问题。同步处理：采用CAS加上失败重试来保证原子性；使用本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，线程在各自的TLAB上分配内存，在TLAB用完需进行性的TLAB分配时才需要同步锁定。&lt;/li&gt;
&lt;li&gt;将分配的内存空间初始化为零值。&lt;/li&gt;
&lt;li&gt;对对象进行设置，比如对象的哈希码，GC分代年龄信息，属于哪个类的实例等，这些都放在对象头(Object Header)中。&lt;/li&gt;
&lt;li&gt;执行&lt;init&gt;对象构造器方法。&lt;/init&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3 对象的内存布：分为对象头，实例数据和对其填充&lt;/h3&gt;
&lt;h4&gt;3.1 对象头&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Mark Word：一个32位或者63位的信息，取决于虚拟机是32位还是64位。储存包括哈希码，GC分代年龄，锁状态标志，线程所持有的锁，偏向线程ID，偏向时间戳等。它被设计成一个非固定数据结构，可以根据对象不同状态复用自己的储存空间。&lt;/li&gt;
&lt;li&gt;类型指针：指向类元数据的指针，用来确定对象是哪个类的实例；&lt;/li&gt;
&lt;li&gt;如果是数组，则还要记录长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.2 实例数据&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;包括从父类继承的和子类中定义的；&lt;/li&gt;
&lt;li&gt;储存顺序受虚拟机分配策略参数和字段在源代码中定义的顺序影响：&lt;/li&gt;
&lt;li&gt;HotSpot为longs/doubles, ints, shorts/chars, bytes/booleans, ordinary object pointers&lt;/li&gt;
&lt;li&gt;在满足上述条件下，父类中定义的变量出现在子类之前；&lt;/li&gt;
&lt;li&gt;如果CompactFields被设置，子类中较窄的变量也可能插入到父类变量的空隙中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.3 对象填充&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HotSpot要求对象起始地址必须为8字节的整数倍，对象头正好是8字节的倍数（1倍或2倍），如果实例数据没有对齐，则需要填充。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4 对象访问：通过栈上的reference数据来操作堆上的具体对象，访问具体对象的方法分为：&lt;/h3&gt;
&lt;h4&gt;4.1 句柄&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;堆中划分出一块空间用来作为句柄池。栈中的reference指向句柄地址，两个句柄指针分别指向对象实例地址（在堆中）和对象类型数据地址（在方法区中）。这种定位对象的好处是reference比较稳定，当GC时，对象很可能会被移动，这只要改变句柄中的实例地址指针就可以，reference不需要修改；不好的地方是需要进行两次定位，有额外开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.2 直接指针访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;reference储存的直接就是对象在堆中的地址，对象空间再保存类型数据地址。好处是找到对象只需要进行一次指针定位。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5 虚拟机参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;-Xms 堆最小值，比如-Xms20m表示堆最小值为20MB；&lt;/li&gt;
&lt;li&gt;-Xmx 堆最大值，将-Xms和-Xmx设置成相同可以避免堆自动扩展；&lt;/li&gt;
&lt;li&gt;-Xss栈容量&lt;/li&gt;
&lt;li&gt;-MaxPermSize最大方法区容量&lt;/li&gt;
&lt;li&gt;操作系统内存限制-Xmx-MaxPermSize剩下的就被分给了栈和本地方法栈，可以通过减少最大堆和减少栈容量来换取更多线程。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>Java</category><category>JVM</category><guid>http://www.jiaqili.me/posts/dynamic-memory-allocation/</guid><pubDate>Thu, 26 Nov 2015 15:40:00 GMT</pubDate></item></channel></rss>