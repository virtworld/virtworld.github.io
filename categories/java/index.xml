<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Virtual World</title>
    <link>http://www.jiaqili.me/categories/java/</link>
    <description>Recent content in Java on Virtual World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 18 Aug 2018 10:10:59 +0800</lastBuildDate>
    
	<atom:link href="http://www.jiaqili.me/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>奇怪的printStackTrace引起进程卡住的问题</title>
      <link>http://www.jiaqili.me/post/java-console-printing/</link>
      <pubDate>Sat, 18 Aug 2018 10:10:59 +0800</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-console-printing/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;昨天碰到一个很奇怪的轮询任务卡住的问题。轮询调度框架会按照数据库里配置，周期性地定时启动一些任务。每个定时任务都是一个普通的Java程序，它处理一个周期内累积的业务请求。虽然每次只处理数量非常有限的数百笔业务，但是每笔业务的逻辑都相对复杂，相当于一个时间很短（通常几分钟）的批处理程序。正常情况下，一个任务在运行的时候会将它执行的SQL、读取的文件以及访问的接口信息打印到日志里。&lt;/p&gt;

&lt;p&gt;问题是有一个任务在执行一段时间后突然不再处理业务，停止输出日志，但没有报错，进程也没有退出。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础知识系列6：枚举类型</title>
      <link>http://www.jiaqili.me/post/java-basics-6-enum/</link>
      <pubDate>Sat, 18 Aug 2018 10:08:00 +0800</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-basics-6-enum/</guid>
      <description>&lt;p&gt;这是一个简单的枚举类型的定义。枚举类型是一个类，除了不能被继承以外，它的行为和一个类相近，关键字enum只是为了告诉编译器在生成相应的类的时候采用的一些编译行为。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Size {SMALL , MEDIUM , LARGE}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的枚举类有三个实例，而枚举类的实例是常量，因此都大写。使用枚举常量时要创建它的一个实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Size size = Size.SMALL;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;enum 经常与switch 配合使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Size size;
// do something to get size;
switch(size){
    case SMALL:
    // do something;
    case MEDIUM:
    // do something;
    case LARGE:
    // do something;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础知识系列5：内部类</title>
      <link>http://www.jiaqili.me/post/java-basics-5-innner-class/</link>
      <pubDate>Sat, 18 Aug 2018 10:07:00 +0800</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-basics-5-innner-class/</guid>
      <description>&lt;p&gt;内部类就是定义在另一个类中的类。使用内部类有以下几个好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内部类的方法可以访问其类定义所在作用于的数据，包括私有数据；&lt;/li&gt;
&lt;li&gt;内部类可以对同一个包中的其他类隐藏；&lt;/li&gt;
&lt;li&gt;如果需要定义一个回调函数但不想编写大量代码时，使用匿名内部类比较方便。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础知识系列4：抽象类和接口</title>
      <link>http://www.jiaqili.me/post/java-basics-4-interface/</link>
      <pubDate>Sat, 18 Aug 2018 10:06:00 +0800</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-basics-4-interface/</guid>
      <description>&lt;h1 id=&#34;抽象类和抽象方法&#34;&gt;抽象类和抽象方法&lt;/h1&gt;

&lt;p&gt;包含抽象方法的类被称做抽象类。如果一个类包含一个或多个抽象方法，它必需被定义为抽象类。&lt;/p&gt;

&lt;p&gt;抽象类可以包含具体的数据和具体的方法。抽象类不能实例化，不过可以有一个抽象类的对象变量，但是它只能引用非抽象子类对象。如果从一个抽象类继承，要么实现它所有的抽象方法，要么继承的类也是个抽象类。&lt;/p&gt;

&lt;p&gt;我们也可以创建一个没有任何抽象方法的抽象类，比如用于阻止该类的实例化。&lt;/p&gt;

&lt;p&gt;抽象类的优点是我们可以明确告诉用户哪些方法需要由子类实现，并且可以很容易地将公共方法沿着层次向上移动；抽象类也有限制，Java不允许多重继承，也就是一个类只能扩展于一个类，而每个类可以扩展自多个接口。&lt;/p&gt;

&lt;p&gt;Java不提供多重继承而使用接口来实现类似多重继承的好处在于，避免多重继承的复杂性和低效性。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础知识系列3： Object类</title>
      <link>http://www.jiaqili.me/post/java-basics-3-object/</link>
      <pubDate>Sat, 11 Aug 2018 13:00:00 +0800</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-basics-3-object/</guid>
      <description>&lt;p&gt;Java中每个类都是继承自Object，如果一个类没有显示地指明父类，Object就是它的父类。除了基本类型外，对象、对象数组、基本类型数组都是继承自Object类。本文主要介绍Object的方法。&lt;/p&gt;

&lt;h1 id=&#34;equals方法&#34;&gt;equals方法&lt;/h1&gt;

&lt;p&gt;Object的equals方法使用两个对象的地址是否相同来判断对象是否等价。如果子类没有覆盖equals
方法，那么它也将如此判断，但很多时候我们希望通过对象的状态，即私有数据域中的数据，来判断两个对象是否相同。&lt;/p&gt;

&lt;p&gt;Java语言规范要求equals方法具有以下方面特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自反性&lt;/strong&gt;。对于任何非空的x，x.equals(x)返回true;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称性&lt;/strong&gt;。对于任何引用x和y。当且仅当x.equals(y)返回true，y.equals(x)也应该返回true;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递性&lt;/strong&gt;。对于任何引用x、y 和z。如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;。如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回一样的结果;&lt;/li&gt;
&lt;li&gt;对于任何非空引用x。x.equals(null) 应该返回false。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础知识系列2：修饰符</title>
      <link>http://www.jiaqili.me/post/java-basics-2-modifiers/</link>
      <pubDate>Sat, 11 Aug 2018 12:59:00 +0800</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-basics-2-modifiers/</guid>
      <description>&lt;h1 id=&#34;final数据-方法和类&#34;&gt;final数据、方法和类&lt;/h1&gt;

&lt;h2 id=&#34;final数据&#34;&gt;final数据&lt;/h2&gt;

&lt;p&gt;对基本类型使用final修饰词时，该基本类型在初始化后不能被修改；对对象引用使用final修饰词时，该引用被初始化后不能指向其他对象，但是所指向的对象本身仍旧是可变的。比如final数组引用，这个引用只能指向同一个数组，但是数组本身的元素却是可变的。&lt;/p&gt;

&lt;p&gt;如果某个域被定义为final，则必须在定义处或者构造器中对其进行初始化。final只表示一旦被初始化，其值将不会改变，但不是说在编译期就能知道其值：我们可以使用随机函数初始化它。&lt;/p&gt;

&lt;p&gt;一个既是static又是final 的变量只占据一段不能改变的内存：static表示只有一份，final表示常量。final数据一般出现在不可变的基本类型域或者不可变类的域，对于可变的类，使用final修饰某实例域容易造成混乱。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础知识系列1：常见问题</title>
      <link>http://www.jiaqili.me/post/java-basics-1-basics/</link>
      <pubDate>Sat, 11 Aug 2018 12:58:00 +0800</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-basics-1-basics/</guid>
      <description>&lt;p&gt;本章不是对Java语言语法的总结，而是摘录了一些容易容易出错、遗忘或混淆的基础知识点。&lt;/p&gt;

&lt;h1 id=&#34;操作符&#34;&gt;操作符&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;前缀递增++a，为先计算后生成值；后缀递增a++，为生成值后递增；&lt;/li&gt;
&lt;li&gt;对于对象，==操作符比较的是引用；对于基本类型，==比较的是值。要比较对象的实际内容应该使用equals，详见&lt;code&gt;Java基础知识系列3： Object类&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;布尔值不能被赋值给int类型；在应该是用String的地方使用了布尔值，它们会被转换为恰当的文本形式，比如false；&lt;/li&gt;
&lt;li&gt;直接常量后面加上后缀表示其类型，比如L表示long，D表示double，F表示float；&lt;/li&gt;
&lt;li&gt;八进制用0开头，后面跟0-7的数字；十六进制用0x开头，后面跟0-F；&lt;/li&gt;
&lt;li&gt;布尔类型可以进行的运算很有限，不能进行加减，但是可以进行位运算，可以执行按位与(&amp;amp;)、或(|)、异或(^)，但是不能执行按位非(~);&lt;/li&gt;
&lt;li&gt;移位操作符只能用来处理整数类型，&amp;lt;&amp;lt;左移操作符按操作符右边的位数将操作符左边的操作数向左移动，低位补0；&amp;gt;&amp;gt;有符号右移操作符，符合为正则高位插0，符号为负则高位插1；&amp;gt;&amp;gt;&amp;gt;无符号右移操作符，无论符号如何，高位补0。如果对char, byte, short 等类型进行移位操作，它们会先被转换为int；&lt;/li&gt;
&lt;li&gt;Java允许我们把任何基本类型转换为任何基本类型，但是布尔类型除外，它不能进行任何类型转换；&lt;/li&gt;
&lt;li&gt;float和double转换为整型时，小数部分被舍弃，如果需要四舍五入，则需要用Math.round方法；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一次Java批处理程序的性能调优</title>
      <link>http://www.jiaqili.me/post/java-tuning-batch/</link>
      <pubDate>Fri, 26 Jan 2018 11:33:00 +0800</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-tuning-batch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文记录的是一次对某系统的批处理应用程序的调优过程。主要涉及统计信息收集、代码分析调优、JVM调优以及从单机批处理向多机的拆分过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;批处理模式&#34;&gt;&lt;strong&gt;批处理模式&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;不论需要处理的业务逻辑如何，大部分批处理程序（也包括我们要讨论的）都遵照一种通用的编程模型。虽然不同的公司内部可能对批处理的各种术语有不同的表述，但为了描述清晰，
下文将采用&lt;a rel=&#34;JSR-352&#34; href=&#34;https://www.jcp.org/en/jsr/detail?id=352&#34;&gt;&lt;code&gt;JSR-352&lt;/code&gt;&lt;/a&gt;标准定义的批处理领域语言(Domain Language)。下面我们会对一些基本概念做简略描述。&lt;/p&gt;


&lt;figure class=&#34;center&#34;&gt;
    
        &lt;img src=&#34;http://www.jiaqili.me/images/java-batch-performance-tuning-chn/batch_model.png&#34; alt=&#34;批处理程序模型&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;批处理程序模型&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;如上图所示，我们的批处理程序包含多个作业(Job)，一个作业又包含多个步骤(Step)，一个步骤内部的执行逻辑遵循经典的读取、处理和写入模式。
我们称一个正在运行的批处理程序为批处理实例(Batch Instance)， 同样的有作业实例(Job Instance)和步骤实例(Step Instance)。
不同的批处理会定时运行，根据运行时间点和频率分为日终(End-of-Day)和月末(End-of-Month)批处理。
我们称批处理时间和业务数据时间挂钩，而非日历时间。比如，一个在2018年1月15日03:00am开始运行的批处理，它处理的是2018年1月14日产生的数据，那么我们称它为2018/01/14日终批处理实例。
批处理虽然是非实时数据处理，但是也有需要在XX时间段内完成的要求，这通常是因为要满足为下游系统提供数据的要求。&lt;/p&gt;

&lt;p&gt;作业以及其步骤的执行规则一般定义在XML或者数据库中。首先，我们来看一个作业的内部。
一个作业的正常执行步骤通常有先后逻辑关系，所以一般是串行地按顺序执行(&lt;code&gt;Step1-&amp;gt;Step2-&amp;gt;Step3-&amp;gt;END&lt;/code&gt;)。
但在一个步骤失败的情况下，可以采用不同的策略：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;尝试重复执行该步骤，并在重复指定次数仍失败后改用其他策略(&lt;code&gt;Step1-&amp;gt;Step1&#39;-&amp;gt;Step1&#39;&#39;...&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;跳过该步骤，继续执行下一个步骤(&lt;code&gt;Step1-&amp;gt;Step3-&amp;gt;END&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;终止作业(&lt;code&gt;Step1-&amp;gt;END&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;进入条件分支(&lt;code&gt;Step1-&amp;gt;Step4-&amp;gt;Step5-&amp;gt;END&lt;/code&gt;)， 如下图。&lt;/li&gt;
&lt;/ul&gt;


&lt;figure class=&#34;center&#34;&gt;
    
        &lt;img src=&#34;http://www.jiaqili.me/images/java-batch-performance-tuning-chn/batch_branch.png&#34; alt=&#34;作业内步骤的条件分支&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;作业内步骤的条件分支&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;接着，我们再来看作业间的关系。作业可以作业一个步骤嵌套在另一个作业中，多个相互独立的作业也可以并行执行。如下图：&lt;/p&gt;


&lt;figure class=&#34;center&#34;&gt;
    
        &lt;img src=&#34;http://www.jiaqili.me/images/java-batch-performance-tuning-chn/batch_jobs.png&#34; alt=&#34;作业嵌套和并行执行&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;作业嵌套和并行执行&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>结构化并发应用程序</title>
      <link>http://www.jiaqili.me/post/java-concurrency-2/</link>
      <pubDate>Mon, 28 Dec 2015 08:10:20 +0000</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-concurrency-2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇是《Java并发实践》的第二篇总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-executor框架&#34;&gt;1 Executor框架&lt;/h1&gt;

&lt;p&gt;任务是一个逻辑执行单元，而线程是使任务异步执行的机制。串行执行会降低响应性和吞吐量；每个任务都分配一个线程会造成很大开销也不利于资源管理。&lt;/p&gt;

&lt;p&gt;该框架包括一个灵活的线程池，提供了不同类型的任务的执行策略，并将任务提交过程和执行过程解耦，用Runnable来表示一个任务。此外Executor框架还提供了对生命周期的支持，以及统计信息的收集、应用程序管理机制和性能监视等机制。&lt;/p&gt;

&lt;p&gt;执行策略定义了任务执行的&amp;rdquo;what, where, when, how&amp;rdquo;等方面。比如在什么线程中执行任务，按什么顺序执行，多少个任务可以并发执行，队列了可以有多少个任务在等待，在任务执行之前和之后应该进行哪些操作，如果要拒绝一个任务，应该选择哪一个？等等&lt;/p&gt;

&lt;p&gt;当需要灵活的执行策略时，用Executor框架来代替手动编写Thread。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>线程安全基础知识</title>
      <link>http://www.jiaqili.me/post/java-concurrency-1/</link>
      <pubDate>Mon, 28 Dec 2015 07:50:12 +0000</pubDate>
      
      <guid>http://www.jiaqili.me/post/java-concurrency-1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇是《Java并发实践》的第一篇笔记，针对第2-3,5,13,15章的总结。书中所介绍的非阻塞的并发算法和数据结构比较粗略，仅限于特性和应用介绍，很少有具体实现，这里也做简单记录。更多的内容可以参考《多处理器编程的艺术》第一修订版以及&lt;a href=&#34;https://www.cs.ox.ac.uk/teaching/materials15-16/cads。以后单独总结。&#34;&gt;https://www.cs.ox.ac.uk/teaching/materials15-16/cads。以后单独总结。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;编写线程安全代码的核心在于对共享的可变的状态的访问操作进行管理。状态指储存在实例或静态域中的数据；共享表示变量可被多个线程同时访问；可变意味着变量值在其生命周期内可以发生变化。&lt;/p&gt;

&lt;p&gt;当多个线程访问某个可变的状态变量，并且至少有一个写线程时，需要采用同步机制。Java的同步机制，主要是Synchronized关键词，volatile变量，显示锁(Explicit Lock)，以及原子变量(Atomic Variables)。否则，要么该变量不在多线程中共享，要么将其设置为不可变。&lt;/p&gt;

&lt;h1 id=&#34;1-线程安全性&#34;&gt;1 线程安全性&lt;/h1&gt;

&lt;p&gt;线程安全的程序并不一定完全由线程安全类构成，完全由线程安全类构成的程序也未必是线程安全的。线程安全性只与状态相关，只能用于封装其状态的整个代码，比如线程安全类，或者线程安全程序。&lt;/p&gt;

&lt;p&gt;定义：当多个线程访问某个类时，不管运行时环境采取何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类时线程安全的。&lt;/p&gt;

&lt;p&gt;线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。一个无状态的类肯定是线程安全的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>